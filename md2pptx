#!/usr/bin/env python3

"""
md2pptx - Converts (a subset of) Markdown to Powerpoint (PPTX)

First argument is file to write to

Reads from stdin

"""

import re
import sys
import os
import time
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor, MSO_THEME_COLOR
from pptx.enum.text import MSO_AUTO_SIZE, PP_ALIGN
from pptx.enum.shapes import PP_PLACEHOLDER
from pptx.enum.shapes import MSO_SHAPE
from pptx.enum.text import MSO_ANCHOR
from pptx.enum.action import PP_ACTION
from pptx.dml.color import RGBColor
import imghdr, struct
import datetime
import html.parser
from pptx.oxml.xmlchemy import OxmlElement
from pathlib import Path
import urllib.request
import tempfile
import copy

# import xml.etree
from lxml import etree

# Try to import CairoSVG - which might not be installed.
# Flag availability or otherwise
try:
    import cairosvg

    have_cairosvg = True
except:
    have_cairosvg = False

md2pptx_level = "1.9.2"
md2pptx_date = "16 March, 2021"


class slideInfo:
    def __init__(self, titleText, bodyText, blockType, bulletsOrFilename, tableRows):
        self.titleText = titleText
        self.bodyText = bodyText
        self.blockType = blockType
        self.bulletsOrFilename = bulletsOrFilename
        self.tableRows = tableRows


def startswithOneOf(haystack, needleList):
    for needle in needleList:
        if haystack.startswith(needle):
            return True

    return False


# Send a shape to the back on a slide
def sendToBack(shapes, shape):
    firstShapeElement = shapes[0]._element
    firstShapeElement.addprevious(shape._element)


# Turn a paragraph into a numbered inList item
def makeNumberedListItem(p):
    if (
        p._element.getchildren()[0].tag
        == "{http://schemas.openxmlformats.org/drawingml/2006/main}pPr"
    ):
        pPr = p._element.getchildren()[0]
        if len(pPr.getchildren()) > 0:
            # Remove Default Text Run Properties element - if present
            x = pPr.getchildren()[0]
            if x.tag == "{http://schemas.openxmlformats.org/drawingml/2006/main}defRPr":
                pPr.remove(x)
    else:
        pPr = OxmlElement("a:pPr")
        p._element.insert(0, pPr)

    buFont = OxmlElement("a:buFont")
    buFont.set("typeface", "+mj-lt")
    pPr.append(buFont)

    buAutoNum = OxmlElement("a:buAutoNum")
    buAutoNum.set("type", "arabicPeriod")
    pPr.append(buAutoNum)


# Add a drop shadow to a shape
def createShadow(shape):
    spPr = shape.fill._xPr

    el = OxmlElement("a:effectLst")
    spPr.append(el)

    outerShdw = OxmlElement("a:outerShdw")
    outerShdw.set("algn", "tl")
    outerShdw.set("blurRad", "50800")
    outerShdw.set("dir", "2700000")
    outerShdw.set("dist", "95250")
    outerShdw.set("rotWithShape", "0")

    el.append(outerShdw)

    prstClr = OxmlElement("a:prstClr")
    prstClr.set("val", "black")

    outerShdw.append(prstClr)

    alpha = OxmlElement("a:alpha")
    alpha.set("val", "40000")

    prstClr.append(alpha)


# Clone a shape in a slide and return the new shape.
# (This is a deep copy so the new shape will have the same
# eg bullet style as the source shape)
def addClonedShape(slide, shape1):
    # Clone the element for the shape
    el1 = shape1.element
    el2 = copy.deepcopy(el1)

    # Insert the cloned element into the shape tree
    slide.shapes._spTree.insert_element_before(el2, "p:extLst")

    # Return the shape associated with this new element
    return slide.shapes[-1]


def parseThemeColour(value):
    value2 = value.upper()
    if value2 == "NONE":
        return MSO_THEME_COLOR.NOT_THEME_COLOR
    elif value2 == "ACCENT 1":
        return MSO_THEME_COLOR.ACCENT_1
    elif value2 == "ACCENT 2":
        return MSO_THEME_COLOR.ACCENT_2
    elif value2 == "ACCENT 3":
        return MSO_THEME_COLOR.ACCENT_3
    elif value2 == "ACCENT 4":
        return MSO_THEME_COLOR.ACCENT_4
    elif value2 == "ACCENT 5":
        return MSO_THEME_COLOR.ACCENT_5
    elif value2 == "ACCENT 6":
        return MSO_THEME_COLOR.ACCENT_6
    elif value2 == "BACKGROUND 1":
        return MSO_THEME_COLOR.BACKGROUND_1
    elif value2 == "BACKGROUND 2":
        return MSO_THEME_COLOR.BACKGROUND_2
    elif value2 == "DARK 1":
        return MSO_THEME_COLOR.DARK_1
    elif value2 == "DARK 2":
        return MSO_THEME_COLOR.DARK_2
    elif value2 == "FOLLOWED HYPERLINK":
        return MSO_THEME_COLOR.FOLLOWED_HYPERLINK
    elif value2 == "HYPERLINK":
        return MSO_THEME_COLOR.HYPERLINK
    elif value2 == "LIGHT 1":
        return MSO_THEME_COLOR.LIGHT_1
    elif value2 == "LIGHT 2":
        return MSO_THEME_COLOR.LIGHT_2
    elif value2 == "TEXT 1":
        return MSO_THEME_COLOR.TEXT_1
    elif value2 == "TEXT 2":
        return MSO_THEME_COLOR.TEXT_2
    elif value2 == "MIXED":
        return MSO_THEME_COLOR.MIXED


# Following functions are workarounds for python-pptx not having these functions for the font object
def set_subscript(font):
    if font.size < Pt(24):
        font._element.set("baseline", "-50000")
    else:
        font._element.set("baseline", "-25000")


def set_superscript(font):
    if font.size < Pt(24):
        font._element.set("baseline", "60000")
    else:
        font._element.set("baseline", "30000")


def set_strikethrough(font):
    font._element.set("strike", "sngStrike")


def set_highlight(run, color):
    # get run properties
    rPr = run._r.get_or_add_rPr()

    # Create highlight element
    hl = OxmlElement("a:highlight")

    # Create specify RGB Colour element with color specified
    srgbClr = OxmlElement("a:srgbClr")
    setattr(srgbClr, "val", color)

    # Add colour specification to highlight element
    hl.append(srgbClr)

    # Add highlight element to run properties
    rPr.append(hl)

    return run


def removeBullet(paragraph):
    pPr = paragraph._p.get_or_add_pPr()
    pPr.insert(
        0,
        etree.Element("{http://schemas.openxmlformats.org/drawingml/2006/main}buNone"),
    )


def removeBullets(textFrame):
    for p in textFrame.paragraphs:
        removeBullet(p)


# Get the slide object the run is in
def SlideFromRun(run):
    return run._parent._parent._parent._parent._parent


# Get the slide object the picture is in
def SlideFromPicture(picture):
    return picture._parent._parent


# Creates a hyperlink to another slide and/or a tooltip - for a
# text run
# Note: To get just a tooltip make to_slide be the source slide
#       so it links to itself.
def createRunHyperlinkOrTooltip(run, to_slide, tooltipText=""):
    # Get hold of the shape the run is in
    if run._parent._parent._parent.__class__.__name__ == "_Cell":
        # Run in a table cell has to be handled differently
        shape = (
            run._parent._parent._parent._parent._parent._parent._parent._graphic_frame
        )
    else:
        # Ordinary text run
        shape = run._parent._parent._parent

    if to_slide == None:
        to_slide = SlideFromRun(run)
    hl = run.hyperlink
    sca = shape.click_action
    sca_hl = sca.hyperlink

    # Add a click action to generate an internal hyperlink address
    sca.target_slide = to_slide

    # Use that internal hyperlink address for the run
    hl.address = sca_hl.address

    # Also clone the hyperlink click action
    hl._hlinkClick.action = sca_hl._hlink.action
    if tooltipText != "":
        hl._hlinkClick.set("tooltip", tooltipText)

    # Also clone the hyperlink rId
    hl._hlinkClick.rId = sca_hl._hlink.rId

    # Delete the shape click action
    sca.target_slide = None


# Creates a hyperlink to another slide or a URL and/or a tooltip - for a
# picture
# Note: To get just a tooltip make to_slide be the source slide
#       so it links to itself.
def createPictureHyperlinkOrTooltip(picture, target, tooltipText=""):
    if target == None:
        # If neither a tooltip nor a target slide then return having
        # done nothing
        if tooltipText == "":
            return

        # Tooltip but no target slide
        target = SlideFromPicture(picture)
        picture.click_action.target_slide = target
    elif target.__class__.__name__ == "str":
        # Is a URL
        picture.click_action.hyperlink.address = target
    else:
        picture.click_action.target_slide = target

    if tooltipText != "":
        picture.click_action.hyperlink._hlink.set("tooltip", tooltipText)


# If a tooltip has been set return it else return an empty string
def getPictureTooltip(picture):
    if picture.click_action.hyperlink._hlink != None:
        # There is a tooltip
        return picture.click_action.hyperlink._hlink.get("tooltip")
    else:
        # There is no tooltip
        return ""


def get_image_size(fname):
    """Determine the image type of fhandle and return its size.
    from draco"""
    try:
        with open(fname, "rb") as fhandle:
            head = fhandle.read(24)
            if len(head) != 24:
                return -1, -1
            if imghdr.what(fname) == "png":
                check = struct.unpack(">i", head[4:8])[0]
                if check != 0x0D0A1A0A:
                    return
                width, height = struct.unpack(">ii", head[16:24])
            elif imghdr.what(fname) == "gif":
                width, height = struct.unpack("<HH", head[6:10])
            elif imghdr.what(fname) == "jpeg":
                try:
                    fhandle.seek(0)  # Read 0xff next
                    size = 2
                    ftype = 0
                    while not 0xC0 <= ftype <= 0xCF:
                        fhandle.seek(size, 1)
                        byte = fhandle.read(1)
                        while ord(byte) == 0xFF:
                            byte = fhandle.read(1)
                        ftype = ord(byte)
                        size = struct.unpack(">H", fhandle.read(2))[0] - 2
                    # We are at a SOFn block
                    fhandle.seek(1, 1)  # Skip 'precision' byte.
                    height, width = struct.unpack(">HH", fhandle.read(4))
                except Exception:  # IGNORE:W0703
                    return
            else:
                return
            return width, height
    except EnvironmentError:
        return -1, -1


# Takes a inList of bullets and applies it to a text shape
def populateTextBlock(shape, bullets):
    tf = shape.text_frame

    bulletNumber = 0
    for bullet in bullets:
        para0 = tf.paragraphs[0]

        if bulletNumber == 0:
            # Don't need to create paragraph
            p = para0
        else:
            # We need a new paragraph
            p = tf.add_paragraph()

        # Set the paragraph's level
        p.level = int(bullet[0] - 1)

        # Set the paragraph's font size, adjusted for level, if necessary
        if baseTextSize > 0:
            p.font.size = Pt(baseTextSize - p.level * baseTextDecrement)

        addFormattedText(p, bullet[1])

        if bullet[2] == "numbered":
            makeNumberedListItem(p)

        bulletNumber = bulletNumber + 1

    tf.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE


def findSlideTitle(slide):
    if slide.shapes.title == None:
        # Have to use first shape as title
        return slide.shapes[0]
    else:
        return slide.shapes.title


def findBodyShape(slide):
    if len(slide.shapes) > 1:
        return slide.shapes[1]
    elif slide.shapes.title == None:
        return slide.shapes[0]
    else:
        return None


# Returns a top, left, width, height for content to be rendered into
def getContentRect(presentation, slide, topOfContent):
    # Left and right are always defined by the margins
    rectLeft = marginBase
    rectWidth = presentation.slide_width - 2 * marginBase

    if topOfContent == 0:
        # There is no title on this slide
        rectTop = marginBase
        rectHeight = (
            presentation.slide_height - marginBase - max(marginBase, numbersHeight)
        )
    else:
        # There is a title on this slide
        rectTop = topOfContent + marginBase
        rectHeight = (
            presentation.slide_height - rectTop - max(marginBase, numbersHeight)
        )

    return (rectLeft, rectWidth, rectTop, rectHeight)


# Finds the title and adds the text to it, returning title bottom, title shape, and
# flattened title
def formatTitle(presentation, slide, titleText, titleFontSize):
    # Find title
    title = findSlideTitle(slide)

    if titleText == "&nbsp;":
        deleteSimpleShape(title)

        return (marginBase, None, "<No title>")

    title.top = marginBase
    title.left = marginBase
    title.width = presentation.slide_width - marginBase * 2

    # Figure out how many lines title will need (ignoring overflow)
    titleLineCount = len(titleText.split("<br/>"))

    # Add the title text to the first paragraph
    flattenedTitle = addFormattedText(title.text_frame.paragraphs[0], titleText)

    title.height = Pt(titleFontSize) * titleLineCount
    title.text_frame.paragraphs[0].font.size = Pt(titleFontSize)
    title.text_frame.vertical_anchor = MSO_ANCHOR.TOP

    # Return where the next shape below the title would be - vertically
    return (title.top + title.height + Inches(0.1), title, flattenedTitle)


# Parse the string after the e.g. ### for a displayable title and
# an optional heading reference
def parseTitleText(titleLineString):
    # Get rid of any cruft on the line
    slideTitleWithPossibleHref = titleLineString.strip().rstrip("#").rstrip()

    if (hrefMatch := slideHrefRegex.match(slideTitleWithPossibleHref)) :
        slideTitle = hrefMatch.group(1)
        href = hrefMatch.group(2)
    else:
        href = ""
        slideTitle = slideTitleWithPossibleHref
    return slideTitle, href


def parseText(text):
    textArray = []
    state = "N"
    fragment = ""
    lastChar = ""

    # Replace any "\#" strings with entity reference
    text2 = text.replace("\\#", "&#x23;")

    # Replace any "<br/>" strings with newline single character
    text2 = text2.replace("<br/>", "\n")

    # Replace any escaped asterisk strings with entity reference
    text2 = text2.replace("\\*", "&lowast;")

    # Replace certain entity references with actual characters
    text2 = text2.replace("&equals;", "=")
    text2 = text2.replace("&lt;", chr(236))
    text2 = text2.replace("&gt;", chr(237))
    text2 = text2.replace("&le;", "≤")
    text2 = text2.replace("&ge;", "≥")
    text2 = text2.replace("&asymp;", "≈")
    text2 = text2.replace("&Delta;", "Δ")
    text2 = text2.replace("&delta;", "δ")
    text2 = text2.replace("&sim;", "∼")
    text2 = text2.replace("&semi;", ";")
    text2 = text2.replace("&colon;", ":")
    text2 = text2.replace("&comma;", ",")
    text2 = text2.replace("&amp;", "&")
    text2 = text2.replace("&larr;", "←")
    text2 = text2.replace("&rarr;", "→")
    text2 = text2.replace("&uarr;", "↑")
    text2 = text2.replace("&darr;", "↓")
    text2 = text2.replace("&harr;", "↔")
    text2 = text2.replace("&varr;", "↕")
    text2 = text2.replace("&nwarr;", "↖")
    text2 = text2.replace("&nearr;", "↗")
    text2 = text2.replace("&swarr;", "↙")
    text2 = text2.replace("&searr;", "↘")
    text2 = text2.replace("&lsqb;", "\[")
    text2 = text2.replace("&rsqb;", "\]")
    text2 = text2.replace("&infin;", "∞")
    text2 = text2.replace("&auml;", "ä")
    text2 = text2.replace("&Auml;", "Ä")
    text2 = text2.replace("&uuml;", "ü")
    text2 = text2.replace("&Uuml;", "Ü")
    text2 = text2.replace("&ouml;", "ö")
    text2 = text2.replace("&Ouml;", "Ö")
    text2 = text2.replace("&szlig;", "ß")
    text2 = text2.replace("&euro;", "€")
    text2 = text2.replace("&check;", "✓")

    # Replace any asterisks with spaces either side with entity reference
    text2 = text2.replace(" * ", " &lowast; ")
    if text2[-2:] == " *":
        text2 = text2[:-2] + " &lowast;"

    # Replace any footnote reference starts with char 238
    text2 = text2.replace("[^", chr(238))

    # Replace any potential footnote reference ends with char 239
    # Don't anymore because it collides with end-of-footnote
    # text2 = text2.replace("]", chr(239))

    # Replace any span class starts with char 240
    text2 = re.sub(spanRegex, chr(240), text2)

    # Replace any span ends with char 241
    text2 = text2.replace("</span>", chr(241))

    # Replace any abbreviation starts with char 242
    text2 = text2.replace("<abbr title=", chr(242))

    # Replace any abbreviation ends with char 243
    text2 = text2.replace("</abbr>", chr(243))

    # Replace any \[ with char 244
    text2 = text2.replace("\[", chr(244))

    # Replace any \] with char 245
    text2 = text2.replace("\]", chr(245))

    # 246 is link separator special character. See below

    # Replace any {~~ with char 247
    text2 = text2.replace("{~~", chr(247))

    # Replace any ~~} with char 247
    text2 = text2.replace("~~}", chr(247))

    # Replace any {== with char 248
    text2 = text2.replace("{==", chr(248))

    # Replace any ==} with char 248
    text2 = text2.replace("==}", chr(248))

    # Replace any {>> with char 249
    text2 = text2.replace("{>>", chr(249))

    # Replace any <<} with char 249
    text2 = text2.replace("<<}", chr(249))

    # Replace any {-- with char 250
    text2 = text2.replace("{--", chr(250))

    # Replace any --} with char 250
    text2 = text2.replace("--}", chr(250))

    # Replace any {++ with char 251
    text2 = text2.replace("{++", chr(251))

    # Replace any ++} with char 251
    text2 = text2.replace("++}", chr(251))

    # Replace any <ins> with char 252
    text2 = text2.replace("<ins>", chr(252))

    # Replace any </ins> with char 252
    text2 = text2.replace("</ins>", chr(252))

    # Replace any <del> with char 253
    text2 = text2.replace("<del>", chr(253))

    # Replace any </del> with char 253
    text2 = text2.replace("</del>", chr(253))

    # Replace any <sub> with char 254
    text2 = text2.replace("<sub>", chr(254))

    # Replace any </sub> with char 254
    text2 = text2.replace("</sub>", chr(254))

    # Replace any <sup> with char 255
    text2 = text2.replace("<sup>", chr(255))

    # Replace any </sup> with char 255
    text2 = text2.replace("</sup>", chr(255))

    # Handle escaped underscore
    text2 = text2.replace("\_", "_")

    # Unescape any numeric character references
    h = html.parser.HTMLParser()

    textSplit = re.split("(&\#x?[0-9a-f]{2,6};)", text2, flags=re.IGNORECASE)
    text3 = ""
    for t in textSplit:
        if t == "":
            text3 = text3 + t
        elif (t[0:2] == "&#") & (t[-1] == ";"):
            text3 = text3 + html.unescape(t).encode("utf-8")
        else:
            text3 = text3 + t

    for c in text3:
        if c == "*":
            # Changing state
            if state == "N":
                # First * potentially starts italic
                textArray.append([state, fragment])
                fragment = ""
                state = "I"
            elif state == "I":
                # Either go to bold or end italic
                if lastChar == "*":
                    # Go to bold
                    state = "B1"
                else:
                    # End italic
                    textArray.append([state, fragment])
                    fragment = ""
                    state = "N"
            elif state == "B1":
                # Starting to close bold bracket
                state = "B2"
            elif lastChar == "*":
                # closing either bold or italic bracket
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif c == "`":
            if state == "N":
                # Going to code
                textArray.append([state, fragment])
                fragment = ""
                state = "C"
            else:
                # exiting code
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 247:
            # Entering or leaving CriticMarkup replacement
            if state == "N":
                # Going to CriticMarkup replacement
                textArray.append([state, fragment])
                fragment = ""
                state = "CMRep"
            else:
                # exiting CriticMarkup replacement
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 248:
            # Entering or leaving CriticMarkup highlight
            if state == "N":
                # Going to CriticMarkup highlight
                textArray.append([state, fragment])
                fragment = ""
                state = "CMHig"
            else:
                # exiting CriticMarkup highlight
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 249:
            # Entering or leaving CriticMarkup comment
            if state == "N":
                # Going to CriticMarkup comment
                textArray.append([state, fragment])
                fragment = ""
                state = "CMCom"
            else:
                # exiting CriticMarkup comment
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 250:
            # Entering or leaving CriticMarkup deletion
            if state == "N":
                # Going to CriticMarkup deletion
                textArray.append([state, fragment])
                fragment = ""
                state = "CMDel"
            else:
                # exiting CriticMarkup deletion
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 251:
            # Entering or leaving CriticMarkup addition
            if state == "N":
                # Going to CriticMarkup addition
                textArray.append([state, fragment])
                fragment = ""
                state = "CMAdd"
            else:
                # exiting CriticMarkup addition
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 252:
            # Entering or leaving underline
            if state == "N":
                # Going to underline
                textArray.append([state, fragment])
                fragment = ""
                state = "Ins"
            else:
                # exiting underline
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 253:
            # Entering or leaving strikethrough
            if state == "N":
                # Going to strikethrough
                textArray.append([state, fragment])
                fragment = ""
                state = "Del"
            else:
                # exiting strikethrough
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 254:
            # Entering or leaving subscript
            if state == "N":
                # Going to subscript
                textArray.append([state, fragment])
                fragment = ""
                state = "Sub"
            else:
                # exiting subscript
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif ord(c) == 255:
            # Entering or leaving superscript
            if state == "N":
                # Going to superscript
                textArray.append([state, fragment])
                fragment = ""
                state = "Sup"
            else:
                # exiting superscript
                textArray.append([state, fragment])
                fragment = ""
                state = "N"
        elif c == "[":
            if state == "N":
                # Could be entering a Link
                if fragment != "":
                    textArray.append([state, fragment])

                # The bracket is kept in in case there is no matching ]
                fragment = "["
                state = "LinkText1"
        elif c == "]":
            # Could be ending picking up the link text
            if state == "LinkText1":
                # Picked up end of link text
                state = "LinkText2"

                # Remove [ and add a separator to allow for link URL
                fragment = fragment[1:] + chr(246)
            elif state == "fnref":
                # This terminates a footnote reference
                textArray.append([state, fragment])
                state = "N"
                fragment = ""
            else:
                # This was an ordinary square bracket
                fragment += "]"
        elif c == "(":
            # Could be starting to pick up the link URL
            if state == "LinkText2":
                # Picked up start of link URL
                state = "LinkURL1"
            else:
                fragment = fragment + c
        elif c == ")":
            # Could be ending picking up the link URL
            if state == "LinkURL1":
                # Picked up end of link URL
                textArray.append(["Link", fragment])
                fragment = ""
                state = "N"
            else:
                fragment = fragment + c
        elif ord(c) == 236:
            fragment = fragment + "<"
        elif ord(c) == 244:
            fragment = fragment + "["
        elif ord(c) == 245:
            fragment = fragment + "]"
        elif ord(c) == 242:
            if fragment != "":
                textArray.append([state, fragment])
                fragment = ""
            dictEntry = ""
        elif ord(c) == 243:
            dictEntry = fragment.split(">")
            dictAbbrev = dictEntry[1]
            dictFull = dictEntry[0].strip().strip("'").strip('"')
            abbrevDictionary[dictAbbrev] = dictFull
            textArray.append(["Gloss", dictAbbrev, dictAbbrev, dictFull])
            fragment = ""
        elif ord(c) == 240:
            # In span element where we hit the class name
            if fragment != "":
                textArray.append([state, fragment])
                fragment = ""
        elif ord(c) == 241:
            # End of span
            splitting = fragment.split(">")
            spanText = splitting[1]
            className = splitting[0].strip().strip("'").strip('"')
            if (
                (className in bgcolors)
                | (className in fgcolors)
                | (className in emphases)
            ):
                textArray.append(["Span", [className, spanText]])
                fragment = ""
            else:
                print(
                    className
                    + " is not defined. Ignoring reference to it in <span> element."
                )
                fragment = spanText
        elif ord(c) == 238:
            if fragment != "":
                textArray.append([state, fragment])
                fragment = ""
                state = "fnref"
        else:
            fragment = fragment + c

        lastChar = c

    if fragment != "":
        textArray.append([state, fragment])
    return textArray


# Calls the tokeniser and then handles the fragments it gets back
def addFormattedText(p, text):
    # Get back parsed text fragments, along with control information on each
    # fragment
    parsedText = parseText(text)

    # Replace chr(237) with > in each Fragment
    for f in range(len(parsedText)):
        if parsedText[f][0] == "Span":
            parsedText[f][1][1] = parsedText[f][1][1].replace(chr(237), ">")
        else:
            parsedText[f][-1] = parsedText[f][-1].replace(chr(237), ">")

    # Prime flattened Text
    flattenedText = ""
    for fragment in parsedText:
        if fragment[0] == "Gloss":
            fragType, fragDetail, fragTerm, fragTitle = fragment
        else:
            fragType, fragDetail = fragment

        # Break into subfragments around a newline
        if fragType == "Span":
            className, fragText = fragDetail
            subfragments = fragText.split("\n")
        else:
            subfragments = fragDetail.split("\n")

        # Process each subfragment
        sfnum = 0
        for subfragment in subfragments:
            if sfnum > 0:
                # Subfragments after the first need to be preceded by a line break
                p.add_line_break()

            sfnum += 1
            # Ensure "\*" is rendered as a literal asterisk
            subfragment = subfragment.replace("&lowast;", "*")

            # Ensure "\#" is rendered as a literal octothorpe
            subfragment = subfragment.replace("&#x23;", "#")

            run = p.add_run()
            if fragType not in ["Link", "fnref", "Gloss"]:
                run.text = subfragment
            elif fragType == "Gloss":
                run.text = fragTerm

            if fragType == "I":
                font = run.font
                if want_italic_italic == True:
                    font.italic = True
                if want_italic_colour == True:
                    font.color.theme_color = italic_colour
            elif fragType == "Gloss":
                # Add this run to abbrevRunsDictionary - for Glossary fix ups later
                if fragTerm not in abbrevRunsDictionary:
                    abbrevRunsDictionary[fragTerm] = []
                abbrevRunsDictionary[fragTerm].append(run)
            elif fragType == "fnref":
                font = run.font
                font.size = Pt(16)
                set_superscript(font)
                fnref = fragment[1]
                if fnref in footnoteReferences:
                    footnoteNumber = footnoteReferences.index(fnref)
                    run.text = str(footnoteNumber + 1)
                    footnoteRunsDictionary[footnoteNumber] = run
                else:
                    run.text = "[?]"
                    print("Error: Footnote reference '" + fnref + "' unresolved.")
                linkText = "!"
                fragment = ""

            elif fragType == "Span":
                if className in bgcolors:
                    run = set_highlight(run, bgcolors[className])
                if className in fgcolors:
                    font = run.font
                    font.color.rgb = RGBColor.from_string(fgcolors[className])
                if className in emphases:
                    if " bold " in " " + emphases[className] + " ":
                        font.bold = True
                    else:
                        font.bold = False
                    if " italic " in " " + emphases[className] + " ":
                        font.italic = True
                    else:
                        font.italic = False
                    if " underline " in " " + emphases[className] + " ":
                        font.underline = True
                    else:
                        font.underline = False
            elif fragType == "B2":
                font = run.font
                if want_bold_bold == True:
                    font.bold = True
                if want_bold_colour == True:
                    font.color.theme_color = bold_colour
            elif fragType == "C":
                font = run.font
                font.name = monoFont
            elif fragType == "CMRep":
                font = run.font
                font.color.rgb = RGBColor(255, 140, 0)
                run.text = "{~~" + subfragment + "~~}"
            elif fragType == "CMHig":
                font = run.font
                font.color.rgb = RGBColor(195, 0, 195)
                run.text = "{==" + subfragment + "==}"
            elif fragType == "CMCom":
                font = run.font
                font.color.rgb = RGBColor(0, 0, 195)
                run.text = "{>>" + subfragment + "<<}"
            elif fragType == "CMDel":
                font = run.font
                font.color.rgb = RGBColor(195, 0, 0)
                run.text = "{--" + subfragment + "--}"
            elif fragType == "CMAdd":
                font = run.font
                font.color.rgb = RGBColor(0, 195, 0)
                run.text = "{++" + subfragment + "++}"
            elif fragType == "Ins":
                font = run.font
                font.underline = True
            elif fragType == "Del":
                font = run.font
                set_strikethrough(font)
            elif fragType == "Sub":
                font = run.font
                set_subscript(font)
            elif fragType == "Sup":
                font = run.font
                set_superscript(font)
            elif fragType == "Link":
                linkArray = subfragment.split(chr(246))
                linkText = linkArray[0]
                linkURL = linkArray[1]
                run.text = linkText
                if linkURL.startswith("#"):
                    # Is an internal Url
                    linkHref = linkURL[1:].strip()
                    href_runs[linkHref] = run
                else:
                    # Not an internal link so create it
                    hlink = run.hyperlink
                    hlink.address = linkURL

            # Add the flattened text from this subfragment
            if fragType == "Link":
                flattenedText = flattenedText + linkText
            else:
                flattenedText = flattenedText + subfragment

    return flattenedText


def addFooter(presentation, slideNumber, slide):
    shapes = slide.shapes
    footer = shapes.add_textbox(
        Inches(0.1),
        presentation.slide_height - numbersHeight,
        Inches(0.2),
        numbersHeight / 2,
    )
    frame = footer.text_frame
    p = frame.paragraphs[0]
    run = p.add_run()
    run.text = str(slideNumber)
    font = run.font
    font.size = Pt(12)


# Called "Simple" because more complex shapes might not work
def deleteSimpleShape(shape):
    if shape == None:
        return
    shapeElement = shape.element
    shapeElement.getparent().remove(shapeElement)


def createProcessingSummarySlide(presentation, metadata):
    # Use the first slide in the template presentation as the base
    slide = presentation.slides[0]

    # Delete any body shape
    deleteSimpleShape(findBodyShape(slide))

    # Build "run time" text
    now = datetime.datetime.now()
    runTime = now.strftime("%H:%M").lstrip()
    runDate = now.strftime("%e %B, %G").lstrip()
    runDateTime = "Presentation built: " + runTime + " on " + runDate

    # Format title and add title text
    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, banner + "<br/>" + runDateTime, pageTitleSize
    )

    # Work out how many pairs of columns we need
    metadataRows = len(metadata)
    maxMetadataRowsPerColumn = 15
    if metadataRows > 2 * maxMetadataRowsPerColumn:
        metadataColumnPairs = 3
    elif metadataRows > maxMetadataRowsPerColumn:
        metadataColumnPairs = 2
    else:
        metadataColumnPairs = 1

    columns = metadataColumnPairs * 2
    rows = min(maxMetadataRowsPerColumn, metadataRows)

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom
    )

    tableHeight = min(contentHeight, Inches(0.25) * rows)

    # Figure out the width of a single-width column
    columnWidthUnit = int(contentWidth / (2 * metadataColumnPairs))

    # Create the table with the above number of rows and columns
    newTable = slide.shapes.add_table(
        rows, columns, tableMargin, contentTop, contentWidth, tableHeight
    ).table

    # Don't want headings
    newTable.first_row = False

    cols = newTable.columns
    for cp in range(metadataColumnPairs):
        cols[2 * cp].width = columnWidthUnit
        cols[2 * cp + 1].width = columnWidthUnit

    row = 0
    column = 0
    for item in metadata:
        key, value = item

        if row == maxMetadataRowsPerColumn:
            # Move to next column
            column += 2
            row = 0
        newTable.cell(row, column).text = key
        newTable.cell(row, column + 1).text = value
        if metadataColumnPairs == 3:
            newTable.cell(row, column).text_frame.paragraphs[0].font.size = Pt(12)
            newTable.cell(row, column + 1).text_frame.paragraphs[0].font.size = Pt(12)
        elif metadataColumnPairs == 2:
            newTable.cell(row, column).text_frame.paragraphs[0].font.size = Pt(14)
            newTable.cell(row, column + 1).text_frame.paragraphs[0].font.size = Pt(14)
        else:
            newTable.cell(row, column).text_frame.paragraphs[0].font.size = Pt(16)
            newTable.cell(row, column + 1).text_frame.paragraphs[0].font.size = Pt(16)
        row += 1


# Note: This doesn't use formatTitle()
def createTitleOrSectionSlide(
    presentation, slideNumber, titleText, layout, titleSize, subtitleText, subtitleSize
):
    slide = presentation.slides.add_slide(presentation.slide_layouts[layout])

    # Add title
    title = findSlideTitle(slide)
    flattenedTitle = addFormattedText(title.text_frame.paragraphs[0], titleText)

    title.text_frame.paragraphs[0].font.size = Pt(titleSize)

    # Add subtitle - if there is one
    subtitleText = subtitleText.strip()
    if subtitleText != "":
        # There is a subtitle
        subtitleShape = findBodyShape(slide)
        if subtitleShape != None:
            addFormattedText(subtitleShape.text_frame.paragraphs[0], subtitleText)
            subtitleShape.text_frame.paragraphs[0].font.size = Pt(subtitleSize)
        else:
            print("Warning: No subtitle shape on this slide to add text to.")
    else:
        # Reformat subtitle shape to be out of the way
        subtitleShape = findBodyShape(slide)
        if subtitleShape != None:
            subtitleShape.top = title.top + title.height + marginBase * 2
            subtitleShape.width = title.width
            subtitleShape.left = title.left
            subtitleShape.height = marginBase * 2

    print(str(slideNumber).rjust(4) + "   " + flattenedTitle)

    if want_numbers_headings is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def handleWhateverGraphicType(graphicFilename):
    # Handles both physical file and URI file types
    if ":" in graphicFilename:
        # Is a URI - so we have to retrieve it and store it in a temporary file

        # Massage the URI into a printable filename
        if len(graphicFilename) > 50:
            printableGraphicFilename = (
                graphicFilename[:25] + "..." + graphicFilename[-25:]
            )
        else:
            printableGraphicFilename = graphicFilename

        # Retrieve the data
        operUrl = urllib.request.urlopen(graphicFilename)
        data = operUrl.read()

        # Store in a temporary file
        graphicFile = tempfile.NamedTemporaryFile(delete=False)
        graphicFile.write(data)

        if ".svg" in graphicFilename.lower():
            # is a web-based SVG file
            if have_cairosvg:
                # Convert SVG file to temporary PNG

                # Store SVG in a temporary file
                convertedGraphicFile = tempfile.NamedTemporaryFile(delete=False)

                cairosvg.svg2png(file_obj=graphicFile, write_to=convertedGraphicFile)

                # Retrieve the temporary file name
                graphicFilename = convertedGraphicFile.name

            else:
                print("Don't have CairoSVG installed. Terminating.")
                sys.exit()
        else:
            # Retrieve the temporary (PNG) file name
            graphicFilename = graphicFile.name

    else:
        # Files don't get their names edited
        printableGraphicFilename = graphicFilename

        if ".svg" in graphicFilename.lower():
            # is a physical SVG file
            if have_cairosvg:
                # Convert SVG file to temporary PNG

                # Store in a temporary file
                graphicFile = tempfile.NamedTemporaryFile(delete=False)

                cairosvg.svg2png(file_obj=open(graphicFilename), write_to=graphicFile)

                # Retrieve the temporary file name
                graphicFilename = graphicFile.name

            else:
                print("Don't have CairoSVG installed. Terminating.")
                sys.exit()

    return graphicFilename, printableGraphicFilename


def createCodeSlide(presentation, slideNumber, titleText, code):
    # Figure out code slide type
    if code.startswith("<pre"):
        codeType = "pre"
    elif code.startswith("<code"):
        codeType = "code"
    elif code.startswith("```"):
        codeType = "backticks"
    else:
        codeType = "indented"

    if titleText != "":
        slide = presentation.slides.add_slide(
            presentation.slide_layouts[titleOnlyLayout]
        )

        # Add title and constrain its size and placement
        slideTitleBottom, title, flattenedTitle = formatTitle(
            presentation, slide, titleText, pageTitleSize
        )

        print(str(slideNumber).rjust(4) + "     " + flattenedTitle)

    else:
        print(str(slideNumber).rjust(4) + "   " + graphicFilename)

        slide = presentation.slides.add_slide(presentation.slide_layouts[blankLayout])

        slideTitleBottom = Inches(marginBase)

        # Add code

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom
    )

    # Split the code into lines
    codeLines = code.split("\n")

    # Handle any trailing empty lines
    while codeLines[-1] == "":
        codeLines.pop(-1)

    # Handle any leading <pre>, <code>, triple backtick line
    if startswithOneOf(codeLines[0], ["<pre>", "<code>", "```"]):
        codeLines.pop(0)

    # Handle any trailing </pre>, </code>, triple backtick line
    if startswithOneOf(codeLines[-1], ["</pre>", "</code>", "```"]):
        codeLines.pop(-1)

    codeBox = slide.shapes.add_textbox(
        contentLeft, contentTop, contentWidth, contentHeight
    )

    # Try to control text frame but SHAPE_TO_FIT_TEXT doesn't seem to work
    tf = codeBox.text_frame
    tf.auto_size = MSO_AUTO_SIZE.SHAPE_TO_FIT_TEXT
    tf.word_wrap = False

    # Fill the code box with green
    fill = codeBox.fill
    fill.solid()
    fill.fore_color.rgb = RGBColor(223, 255, 223)

    # Get the sole paragraph
    p = codeBox.text_frame.paragraphs[0]

    # Set the font size slightly smaller than usual
    if len(codeLines) >= 20:
        divisor = 1.5
    else:
        divisor = 1.2
    if baseTextSize > 0:
        p.font.size = int(Pt(baseTextSize) / divisor)
    else:
        p.font.size = int(Pt(defaultBaseTextSize) / divisor)

    # Adjust code box height based on lines
    codeBox.height = min(len(codeLines) * Pt(baseTextSize + 5), contentHeight)

    # Add code
    if codeType == "pre":
        # span elements want special handling
        for codeLine in codeLines:
            # Split the line - and maybe there are spans
            cursor = 0
            spanFragments = codeLine.split("<span ")
            if len(spanFragments) > 1:
                textArray = []
                # Break line down into what will become runs
                fragmentNumber = 0
                for fragment in spanFragments:

                    if fragmentNumber > 0:
                        classNameStartsAt = fragment.index('"')
                        classNameEndsAt = fragment.index('"', classNameStartsAt + 1)
                        className = fragment[classNameStartsAt + 1 : classNameEndsAt]
                        if (
                            (className in bgcolors)
                            | (className in fgcolors)
                            | (className in emphases)
                        ):
                            afterSpan = fragment[classNameEndsAt + 2 :]
                            afterSpan1 = afterSpan[: afterSpan.index("</span>")]
                            afterSpan2 = afterSpan[afterSpan.index("</span>") + 7 :]
                            textArray.append(["Span", [className, afterSpan1]])
                            textArray.append(["Normal", afterSpan2])
                            fragment = ""
                        else:
                            print(
                                className
                                + " is not defined. Ignoring reference to it in <span> element."
                            )
                            fragment = spanText
                    else:
                        textArray.append(["Normal", fragment])
                    fragmentNumber += 1

                # Now we have a text array we can add the runs for the line
                for textArrayItem in textArray:
                    if textArrayItem[0] == "Normal":
                        # Is not spanned
                        className = ""
                        spanText = textArrayItem[1]
                    else:
                        # Is spanned
                        className = textArrayItem[1][0]
                        spanText = textArrayItem[1][1]
                    if spanText != "":
                        run = p.add_run()
                        run.text = spanText
                        font = run.font
                        font.name = monoFont
                    if className != "":
                        # Augment run with whatever the span class calls for
                        if className in bgcolors:
                            run = set_highlight(run, bgcolors[className])
                        if className in fgcolors:
                            font = run.font
                            font.color.rgb = RGBColor.from_string(fgcolors[className])
                        if className in emphases:
                            if " bold " in " " + emphases[className] + " ":
                                font.bold = True
                            else:
                                font.bold = False
                            if " italic " in " " + emphases[className] + " ":
                                font.italic = True
                            else:
                                font.italic = False
                            if " underline " in " " + emphases[className] + " ":
                                font.underline = True
                            else:
                                font.underline = False

                # Add terminating newline
                run = p.add_run()
                run.text = "\n"
                font = run.font
                font.name = monoFont
            else:
                # Line has no spans in
                run = p.add_run()
                run.text = codeLine + "\n"
                font = run.font
                font.name = monoFont

    else:
        # span doesn't need treating specially
        for codeLine in codeLines:
            run = p.add_run()
            run.text = codeLine + "\n"
            font = run.font
            font.name = monoFont

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def createAbstractSlide(presentation, slideNumber, titleText, subtitleText, paragraphs):
    slide = presentation.slides.add_slide(presentation.slide_layouts[titleOnlyLayout])

    shapes = slide.shapes

    # Add title and constrain its size and placement
    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, titleText, pageTitleSize
    )

    print(str(slideNumber).rjust(4) + "     Abstract: " + flattenedTitle)

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom
    )

    # Add abstract text
    abstractBox = slide.shapes.add_textbox(
        contentLeft,
        contentTop,
        contentWidth,
        contentHeight,
    )
    p = abstractBox.text_frame.paragraphs[0]
    para = 1
    tf = abstractBox.text_frame
    f = p.font
    f.size = Pt(22)
    for abstractParagraph in paragraphs:
        paragraphLevel, paragraphText, paragraphType = abstractParagraph
        if para > 1:

            # Spacer paragraph
            p = tf.add_paragraph()
            f = p.font
            f.size = Pt(22)

            # Content paragraph
            p = tf.add_paragraph()
            f = p.font
            f.size = Pt(22)
        addFormattedText(p, paragraphText)
        para = para + 1

    tf.word_wrap = True

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def createContentSlide(presentation, slideNumber, titleText, subtitleText, bullets):
    slide = presentation.slides.add_slide(
        presentation.slide_layouts[contentSlideLayout]
    )

    shapes = slide.shapes

    # Add title
    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, titleText, pageTitleSize
    )

    print(str(slideNumber).rjust(4) + "     " + flattenedTitle)

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom
    )

    # Get bulleted text shape - either for bullets above cards or first card's body shape
    bulletsShape = findBodyShape(slide)

    # Set bulleted shape top, left, width
    bulletsShape.top = contentTop
    bulletsShape.left = contentLeft
    bulletsShape.width = contentWidth

    bulletCount = len(bullets)

    # Set bulleted text height - depending on whether there's a card
    # Remainder is card area height - if there are cards
    if inCard:
        if bulletCount > 0:
            # Bullets shape vertically shortened
            bulletsShape.height = int(contentHeight * (100 - cardPercent) / 100)

            # Card area takes the rest of the content area
            cardAreaHeight = int(contentHeight) - bulletsShape.height
        else:
            # No bullets so content is all cards
            bulletsShape.height = 0

            cardAreaHeight = contentHeight
    else:
        # Bullets shape takes the whole content area
        bulletsShape.height = contentHeight

        # There are no cards so the card area is zero height
        cardAreaHeight = 0

    if inCard:
        cardBackgroundShapes = []
        cardBodyShapes = []
        cardTitleShapes = []
        cardLeft = []
        cardTop = []
        cardBodyTop = []
        cardBackgroundTop = []
        cardTitleTop = []

        cardCount = len(cards)

        # card width applies to card title, card background, card body
        if cardLayout == "horizontal":
            # Divide horizontal card space up
            cardWidth = int((contentWidth - Inches(0.25) * (cardCount - 1)) / cardCount)
        else:
            # Card takes all the horizontal space
            cardWidth = int(contentWidth)

        # Calculate title top and height - horizontal layout
        if want_card_title_size:
            # Specified by user
            cardTitleHeightRaw = Inches(cardTitleFontSize / 72)
        else:
            # Shrunk to 2/3 of page title height
            cardTitleHeightRaw = Inches(int(10000 * pageTitleSize * 2 / 3 / 72) / 10000)

        # Adjust title height to be slightly larger than the text
        cardTitleHeight = cardTitleHeightRaw + Inches(0.1)

        if bulletCount > 0:
            # Bullets so cards and their titles occupy less than whole height
            cardAreaTop = bulletsShape.height + slideTitleBottom + Inches(0.25)

        else:
            # No bullets so cards and their titles occupy whole height
            cardAreaTop = slideTitleBottom + Inches(0.25)

        if cardLayout == "horizontal":
            # Card takes up all the card area, vertically
            cardHeight = cardAreaHeight
        else:
            # Card height is just a proportion of the card area height

            if cardTitlePosition == "above":
                paddingFactor = Inches(0.1)
            else:
                paddingFactor = Inches(0.15)

            cardHeight = int((cardAreaHeight) / cardCount - paddingFactor)

        for c in range(cardCount):
            # Calculate a card's vertical position
            if cardLayout == "horizontal":
                cardTop.append(cardAreaTop)
            else:
                cardTop.append(int((cardHeight + paddingFactor) * c + cardAreaTop))

            # Card top and height
            if cardTitlePosition == "above":
                # Card title above card background
                cardBackgroundTop.append(cardTop[c] + cardTitleHeight)
                cardBodyTop.append(cardBackgroundTop[c])
            else:
                # card title inside card background
                cardBackgroundTop.append(cardTop[c])

                # Leave room above the card body for the card title
                cardBodyTop.append(cardBackgroundTop[c] + cardTitleHeight)

            # Calculate a card's horizontal position
            if cardLayout == "horizontal":
                cardLeft.append(int(Inches(0.5) + c * (cardWidth + Inches(0.25))))
            else:
                cardLeft.append(int(Inches(0.5)))

            # Card title modeled on slide title - but smaller
            cardTitleShape = addClonedShape(slide, title)

            cardTitleShapes.append(cardTitleShape)

            # Clear text from cloned title and add in the title text
            cardTitleShape.text_frame.paragraphs[0].text = ""
            addFormattedText(cardTitleShape.text_frame.paragraphs[0], cards[c][0])

            # Set card title font size
            if want_card_title_size:
                cardTitleShape.text_frame.paragraphs[0].font.size = Pt(
                    cardTitleFontSize
                )
            else:
                cardTitleShape.text_frame.paragraphs[0].font.size = Pt(
                    pageTitleSize * 2 / 3
                )

            # Titles are centred
            if cardTitleAlign == "l":
                cardTitleShape.text_frame.paragraphs[0].alignment = PP_ALIGN.LEFT
            elif cardTitleAlign == "c":
                cardTitleShape.text_frame.paragraphs[0].alignment = PP_ALIGN.CENTER
            else:
                cardTitleShape.text_frame.paragraphs[0].alignment = PP_ALIGN.RIGHT

            # Create card background and make sure it's behind the card body (and maybe card title)

            if cardShape == "rounded":
                # Rounded Rectangle for card
                cardBackgroundShape = slide.shapes.add_shape(
                    MSO_SHAPE.ROUNDED_RECTANGLE,
                    Inches(0),
                    Inches(0),
                    Inches(0),
                    Inches(0),
                )

                # Rounding adjustment works better with different values for horizontal and vertical cards
                if cardLayout == "horizontal":
                    # Make the rounding radius small. This is 1/4 the default
                    cardBackgroundShape.adjustments[0] = 0.0416675
                else:
                    # Make the rounding radius smallish. This is 1/2 the default
                    cardBackgroundShape.adjustments[0] = 0.083335
            else:
                # Squared-corner Rectangle for card
                cardBackgroundShape = slide.shapes.add_shape(
                    MSO_SHAPE.RECTANGLE, Inches(0), Inches(0), Inches(0), Inches(0)
                )

            cardBackgroundShapes.append(cardBackgroundShape)
            sendToBack(shapes, cardBackgroundShape)

            # Card shape modeled on bulleted inList
            if (bulletCount > 0) | (c > 0):
                cardBodyShape = addClonedShape(slide, bulletsShape)
            else:
                # Co-opt bullets shape as first card shape
                cardBodyShape = bulletsShape
            cardBodyShapes.append(cardBodyShape)

            # Make card's body transparent
            fill = cardBodyShape.fill
            fill.background()

            # Fill in card's background - if necessary
            if want_card_colour:
                fill = cardBackgroundShape.fill
                fill.solid()
                fill.fore_color.theme_color = card_colour

    else:
        cardCount = 0

    # Adjust bullets shape height - and calculate verticals for any cards

    bulletsShape.bottom = bulletsShape.top + bulletsShape.height

    # Fill in the main bullets shape
    populateTextBlock(bulletsShape, bullets)

    for c in range(cardCount):
        # Get the shapes for this card
        cardBackgroundShape = cardBackgroundShapes[c]
        cardTitleShape = cardTitleShapes[c]
        cardBodyShape = cardBodyShapes[c]

        # Set the card shapes' width
        cardBackgroundShape.width = cardWidth
        cardBodyShape.width = cardWidth
        cardTitleShape.width = cardWidth

        # Set the card shapes' left side
        cardBackgroundShape.left = cardLeft[c]
        cardTitleShape.left = cardLeft[c]
        cardBodyShape.left = cardLeft[c]

        # Position card title
        cardTitleShape.top = cardTop[c]
        cardTitleShape.height = cardTitleHeight

        # Calculate positions and heights within card background of body
        if cardTitlePosition == "above":
            cardBackgroundShape.top = cardTop[c] + cardTitleHeight
            cardBodyHeight = cardHeight - cardTitleHeight
            cardBackgroundShape.height = cardBodyHeight
        else:
            cardBackgroundShape.top = cardTop[c]
            cardBodyHeight = cardHeight
            cardBackgroundShape.height = cardBodyHeight

        # Position card
        cardBodyShape.top = cardBodyTop[c]
        cardBodyShape.height = cardBodyHeight

        if len(cards[c]) > 1:
            populateTextBlock(cardBodyShape, cards[c][1])

        lf = cardBackgroundShape.line

        if want_card_border_colour:
            lf.color.theme_color = card_border_colour

        if want_card_border_width:
            lf.width = Pt(card_border_width)

        if want_card_shadow:
            createShadow(cardBackgroundShape)

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)
    return slide


def delinkify(text):
    if (linkMatch := linkRegex.match(text)) :
        linkText = linkMatch.group(1)
        linkURL = linkMatch.group(2)

        return linkText
    else:
        return text


def createChevron(chevronText, x, y, width, height, filled, shapes):
    shape = shapes.add_shape(MSO_SHAPE.CHEVRON, x, y, width, height)
    shape.text = chevronText
    tf = shape.text_frame
    p = tf.paragraphs[0]
    f = p.font
    f.size = Pt(14)
    shape.line.color.rgb = RGBColor(0, 0, 0)
    f.color.rgb = RGBColor(0, 0, 0)
    shape.line.width = Pt(1.0)

    if filled is False:
        shape.fill.background()


def createTOCSlide(presentation, slideNumber, titleText, subtitleText, bullets):
    print(
        str(slideNumber).rjust(4)
        + '     Table Of Contents (Style: "'
        + tocStyle
        + '") '
        + titleText
    )

    slide = presentation.slides.add_slide(presentation.slide_layouts[titleOnlyLayout])

    shapes = slide.shapes

    # Add title
    if titleText == tocTitle:
        useTitle = tocTitle
    else:
        useTitle = ""

    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, useTitle, pageTitleSize
    )

    # Get the rectangle the content will draw in
    contentLeft, contentWidth, contentTop, contentHeight = getContentRect(
        presentation, slide, slideTitleBottom
    )

    width = Inches(3)
    height = Inches(1)
    rowGap = Inches(0.75)

    chevronsPerRow = 4

    # Create global inList of TOC entries
    for bullet in bullets:
        bulletLevel, bulletText, bulletType = bullet
        if bulletLevel == 1:
            tocEntries.append(delinkify(bulletText))

    rowCount = 1 + len(tocEntries) / chevronsPerRow

    # Calculate actual TOC height so it can be vertically centred
    TOCHeight = (rowCount * height) + ((rowCount - 1) * rowGap)

    TOCtop = slideTitleBottom + (contentHeight - TOCHeight + height) / 2

    # Calculate actual TOC width
    TOCWidth = chevronsPerRow * (width - Inches(0.5)) + Inches(0.5)
    TOCleft = (presentation.slide_width - TOCWidth) / 2

    x = TOCleft
    y = TOCtop
    chevronNumber = 1
    for bulletText in tocEntries:
        if bulletText == titleText:
            wantFilled = False
        else:
            wantFilled = True

        createChevron(bulletText, x, y, width, height, wantFilled, shapes)
        x = x + width - Inches(0.5)
        chevronNumber = chevronNumber + 1
        if chevronNumber == chevronsPerRow + 1:
            x = TOCleft
            y = y + rowGap + height
            chevronNumber = 1

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def createTableSlide(presentation, slideNumber, titleText, table):
    slide = presentation.slides.add_slide(presentation.slide_layouts[titleOnlyLayout])

    shapes = slide.shapes

    printableTopLeftGraphicFilename = ""
    printableTopRightGraphicFilename = ""
    printableBottomLeftGraphicFilename = ""
    printableBottomRightGraphicFilename = ""

    # Add title
    slideTitleBottom, title, flattenedTitle = formatTitle(
        presentation, slide, titleText, pageTitleSize
    )

    # Handle table body
    if (len(table) <= 2) & (len(table[0]) <= 2):
        # This is a table with 1 or 2 rows and 1 or 2 columns
        isGraphicsGrid = True
        gridRows = len(table)
        if gridRows == 1:
            gridColumns = len(table[0])
        else:
            gridColumns = max(len(table[0]), len(table[1]))
        isThreeUp = False
        topGraphicCount = 0

        # Attempt to retrieve filename for left side - top row
        topLeftSide = table[0][0]
        if (graphicRegex.match(topLeftSide) != None) | (
            clickableGraphicRegex.match(topLeftSide) != None
        ):
            if (clickableGraphicMatch := clickableGraphicRegex.match(topLeftSide)) :
                # Clickable graphic case
                topLeftGraphicTitle = clickableGraphicMatch.group(1)
                topLeftGraphicFilename = clickableGraphicMatch.group(2)
                topLeftGraphicHref = clickableGraphicMatch.group(3)
            else:
                # Graphic
                topLeftGraphicMatch = graphicRegex.match(topLeftSide)
                topLeftGraphicTitle = topLeftGraphicMatch.group(1)
                topLeftGraphicFilename = topLeftGraphicMatch.group(2)
                topLeftGraphicHref = ""

            (
                topLeftGraphicFilename,
                printableTopLeftGraphicFilename,
            ) = handleWhateverGraphicType(topLeftGraphicFilename)
            topLeftHTML = ""
            topGraphicCount += 1
        else:
            topLeftGraphicFilename = ""
            topLeftHTML = topLeftSide

        # Attempt to retrieve filename for right side - top row
        if gridColumns == 2:
            if len(table[0]) == 2:
                topRightSide = table[0][1]
            else:
                topRightSide = ""
            if (graphicRegex.match(topRightSide) != None) | (
                clickableGraphicRegex.match(topRightSide) != None
            ):
                if (
                    clickableGraphicMatch := clickableGraphicRegex.match(topRightSide)
                ) :
                    # Clickable graphic case
                    topRightGraphicTitle = clickableGraphicMatch.group(1)
                    topRightGraphicFilename = clickableGraphicMatch.group(2)
                    topRightGraphicHref = clickableGraphicMatch.group(3)
                else:
                    # Graphic
                    topRightGraphicMatch = graphicRegex.match(topRightSide)
                    topRightGraphicTitle = topRightGraphicMatch.group(1)
                    topRightGraphicFilename = topRightGraphicMatch.group(2)
                    topRightGraphicHref = ""

                (
                    topRightGraphicFilename,
                    printableTopRightGraphicFilename,
                ) = handleWhateverGraphicType(topRightGraphicFilename)
                topRightHTML = ""
                topGraphicCount += 1
            else:
                topRightGraphicFilename = ""
                topRightHTML = topRightSide
        else:
            topRightGraphicFilename = ""
            topRightHTML = ""

        if topGraphicCount == 0:
            # Revert to normal table processing as no graphic spec in at least one cell
            isGraphicsGrid = False

        if gridRows == 2:
            # Attempt to retrieve filename for left side - bottom row
            bottomGraphicCount = 0
            bottomLeftSide = table[1][0]
            if (graphicRegex.match(bottomLeftSide) != None) | (
                clickableGraphicRegex.match(bottomLeftSide) != None
            ):
                if (
                    clickableGraphicMatch := clickableGraphicRegex.match(bottomLeftSide)
                ) :
                    # Clickable graphic case
                    bottomLeftGraphicTitle = clickableGraphicMatch.group(1)
                    bottomLeftGraphicFilename = clickableGraphicMatch.group(2)
                    bottomLeftGraphicHref = clickableGraphicMatch.group(3)
                else:
                    # Graphic
                    bottomLeftGraphicMatch = graphicRegex.match(bottomLeftSide)
                    bottomLeftGraphicTitle = bottomLeftGraphicMatch.group(1)
                    bottomLeftGraphicFilename = bottomLeftGraphicMatch.group(2)
                    bottomLeftGraphicHref = ""

                (
                    bottomLeftGraphicFilename,
                    printableBottomLeftGraphicFilename,
                ) = handleWhateverGraphicType(bottomLeftGraphicFilename)
                bottomLeftHTML = ""
                bottomGraphicCount += 1
            else:
                bottomLeftGraphicFilename = ""
                bottomLeftHTML = bottomLeftSide

            # Attempt to retrieve filename for right side - bottom row
            if gridColumns == 2:
                if len(table[1]) == 1:
                    # There is one cell in bottom row so this is centred "3-up"
                    isThreeUp = True
                    bottomRightGraphicFilename = ""
                else:
                    # There is a bottom right so this is "4-up", though one or OTHER_MEMBERS
                    # bottom cells might be empty
                    bottomRightSide = table[1][1]
                    if (graphicRegex.match(bottomRightSide) != None) | (
                        clickableGraphicRegex.match(bottomRightSide) != None
                    ):
                        if (
                            clickableGraphicMatch := clickableGraphicRegex.match(
                                bottomRightSide
                            )
                        ) :
                            # Clickable graphic case
                            bottomRightGraphicTitle = clickableGraphicMatch.group(1)
                            bottomRightGraphicFilename = clickableGraphicMatch.group(2)
                            bottomRightGraphicHref = clickableGraphicMatch.group(3)
                        else:
                            # Graphic
                            bottomRightGraphicMatch = graphicRegex.match(
                                bottomRightSide
                            )
                            bottomRightGraphicTitle = bottomRightGraphicMatch.group(1)
                            bottomRightGraphicFilename = bottomRightGraphicMatch.group(
                                2
                            )
                            bottomRightGraphicHref = ""

                        (
                            bottomRightGraphicFilename,
                            printableBottomRightGraphicFilename,
                        ) = handleWhateverGraphicType(bottomRightGraphicFilename)
                        bottomRightHTML = ""
                        bottomGraphicCount += 1
                    else:
                        bottomRightGraphicFilename = ""
                        bottomRightHTML = bottomRightSide
            else:
                bottomRightGraphicFilename = ""
                bottomRightHTML = ""

            if bottomGraphicCount == 0:
                # Revert to normal table processing as no graphic spec in at least one cell
                isGraphicsGrid = False

    else:
        # This is a normal table because it has too many rows or columns to be a graphics grid
        isGraphicsGrid = False

    if isGraphicsGrid == True:
        if gridColumns == 2:
            # Doing 1- or 2-row side-by-side graphics slide
            print(
                str(slideNumber).rjust(4)
                + "     "
                + flattenedTitle.ljust(50)
                + "   --> "
                + printableTopLeftGraphicFilename.ljust(30)
                + " , "
                + printableTopRightGraphicFilename
            )
        else:
            # Doing 2 row, single column graphics slide
            print(
                str(slideNumber).rjust(4)
                + "     "
                + flattenedTitle.ljust(50)
                + "   --> "
                + printableTopLeftGraphicFilename.ljust(30)
            )

        if gridRows == 2:
            # Second row of filenames
            if gridColumns == 2:
                print(
                    " ".rjust(4)
                    + "     "
                    + " ".ljust(50)
                    + "   --> "
                    + printableBottomLeftGraphicFilename.ljust(30)
                    + " , "
                    + printableBottomRightGraphicFilename
                )
            else:
                print(
                    " ".rjust(4)
                    + "     "
                    + " ".ljust(50)
                    + "   --> "
                    + printableBottomLeftGraphicFilename.ljust(30)
                )

        # Get top left image dimensions
        if topLeftGraphicFilename != "":
            topLeftImgWidth, topLeftImgHeight = get_image_size(topLeftGraphicFilename)
            if topLeftImgWidth == -1:
                if gridRows == 2:
                    print(
                        "Missing top left image file: "
                        + printableTopLeftGraphicFilename
                    )
                else:
                    print("Missing left image file: " + printableTopLeftGraphicFilename)

                return slide

        if gridColumns == 2:
            # Get top right image dimensions
            if topRightGraphicFilename != "":
                topRightImgWidth, topRightImgHeight = get_image_size(
                    topRightGraphicFilename
                )
                if topRightImgWidth == -1:
                    if gridRows == 2:
                        print(
                            "Missing top right image file: "
                            + printableTopRightGraphicFilename
                        )
                    else:
                        print(
                            "Missing right image file: "
                            + printableTopRightGraphicFilename
                        )

                    return slide

        if gridRows == 2:
            # Get bottom left image dimensions
            if bottomLeftGraphicFilename != "":
                bottomLeftImgWidth, bottomLeftImgHeight = get_image_size(
                    bottomLeftGraphicFilename
                )
                if bottomLeftImgWidth == -1:
                    print(
                        "Missing bottom left image file: "
                        + printableBottomLeftGraphicFilename
                    )
                    return slide

            if gridColumns == 2:
                if isThreeUp is True:
                    bottomRightImgWidth = 0
                    bottomRightImgHeight = 0
                else:
                    # Get bottom right image dimensions
                    if bottomRightGraphicFilename != "":
                        bottomRightImgWidth, bottomRightImgHeight = get_image_size(
                            bottomRightGraphicFilename
                        )
                        if bottomRightImgWidth == -1:
                            print(
                                "Missing bottom right image file: "
                                + printableBottomRightGraphicFilename
                            )
                            return slide

        # Figure out graphic height on slide
        maxPicHeight = (
            presentation.slide_height - slideTitleBottom - numbersContentMargin
        )

        if gridRows == 2:
            # gridRows adjusted if two rows
            maxPicHeight = maxPicHeight / 2 + Inches(0.2)

        # Middle of slide
        midSlideX = presentation.slide_width / 2

        # Figure out picture width - with 0.5 inch margin plus 0.25 inch other margin
        # (Unaffected by whether gridRows is 1 or 2)
        if gridColumns == 2:
            maxPicWidth = midSlideX - marginBase * 3
        else:
            maxPicWidth = presentation.slide_width - marginBase * 2

        # Top Left Picture
        if topLeftGraphicFilename != "":
            topLeftHeightIfWidthUsed = maxPicWidth * topLeftImgHeight / topLeftImgWidth
            topLeftWidthIfHeightUsed = maxPicHeight * topLeftImgWidth / topLeftImgHeight

            if topLeftHeightIfWidthUsed > maxPicHeight:
                # Use the height to scale
                topLeftPicWidth = topLeftWidthIfHeightUsed
                topLeftPicHeight = maxPicHeight

                # Calculate horizontal start
                if gridColumns == 2:
                    # Align top left picture to the left
                    topLeftPicX = (
                        marginBase + (midSlideX - marginBase - topLeftPicWidth) / 2
                    )
                else:
                    # Center sole top picture
                    topLeftPicX = midSlideX - topLeftPicWidth / 2
            else:
                # Use the width to scale
                topLeftPicWidth = maxPicWidth
                topLeftPicHeight = topLeftHeightIfWidthUsed

                # Calculate horizontal start
                if (gridColumns == 2) & (topRightGraphicFilename != ""):
                    # Align top left picture to the left
                    topLeftPicX = marginBase
                else:
                    # Center sole top picture
                    topLeftPicX = midSlideX - topLeftPicWidth / 2

            # Calculate vertical start
            topLeftPicY = (
                slideTitleBottom + marginBase + (maxPicHeight - topLeftPicHeight) / 2
            )

            if gridRows == 2:
                topLeftPicY -= Inches(0.2)

            topLeftPicture = slide.shapes.add_picture(
                topLeftGraphicFilename,
                topLeftPicX,
                topLeftPicY,
                topLeftPicWidth,
                topLeftPicHeight,
            )

            if topLeftGraphicHref == "":
                topLeftGraphicHref = "#XYZZY-None"

            pictureInfos.append(
                (topLeftPicture, topLeftGraphicHref, topLeftGraphicTitle)
            )

        if gridColumns == 2:
            # Top Right Picture
            if topRightGraphicFilename != "":
                topRightHeightIfWidthUsed = (
                    maxPicWidth * topRightImgHeight / topRightImgWidth
                )
                topRightWidthIfHeightUsed = (
                    maxPicHeight * topRightImgWidth / topRightImgHeight
                )

                if topRightHeightIfWidthUsed > maxPicHeight:
                    # Use the height to scale
                    topRightPicWidth = topRightWidthIfHeightUsed
                    topRightPicHeight = maxPicHeight

                    # Calculate horizontal start
                    topRightPicX = (
                        presentation.slide_width
                        + midSlideX
                        - topRightPicWidth
                        - marginBase
                    ) / 2
                else:
                    # Use the width to scale
                    topRightPicWidth = maxPicWidth
                    topRightPicHeight = topRightHeightIfWidthUsed

                    # Calculate horizontal start
                    topRightPicX = (
                        presentation.slide_width
                        + midSlideX
                        - topRightPicWidth
                        - marginBase
                    ) / 2

                # Calculate vertical start
                topRightPicY = (
                    slideTitleBottom
                    + marginBase
                    + (maxPicHeight - topRightPicHeight) / 2
                )

                if gridRows == 2:
                    topRightPicY -= Inches(0.2)

                topRightPicture = slide.shapes.add_picture(
                    topRightGraphicFilename,
                    topRightPicX,
                    topRightPicY,
                    topRightPicWidth,
                    topRightPicHeight,
                )

                if topRightGraphicHref == "":
                    topRightGraphicHref = "#XYZZY-None"

                pictureInfos.append(
                    (topRightPicture, topRightGraphicHref, topRightGraphicTitle)
                )

        if gridRows == 2:
            # Need second row of pictures
            # Bottom Left Picture
            if bottomLeftGraphicFilename != "":
                bottomLeftHeightIfWidthUsed = (
                    maxPicWidth * bottomLeftImgHeight / bottomLeftImgWidth
                )
                bottomLeftWidthIfHeightUsed = (
                    maxPicHeight * bottomLeftImgWidth / bottomLeftImgHeight
                )

                if bottomLeftHeightIfWidthUsed > maxPicHeight:
                    # Use the height to scale
                    bottomLeftPicWidth = bottomLeftWidthIfHeightUsed
                    bottomLeftPicHeight = maxPicHeight

                    # Calculate horizontal start
                    if (gridColumns == 2) & (bottomRightGraphicFilename != ""):
                        bottomLeftPicX = (
                            marginBase
                            + (midSlideX - marginBase - bottomLeftPicWidth) / 2
                        )
                    else:
                        bottomLeftPicX = midSlideX - bottomLeftPicWidth / 2
                else:
                    # Use the width to scale
                    bottomLeftPicWidth = maxPicWidth
                    bottomLeftPicHeight = bottomLeftHeightIfWidthUsed

                    # Calculate horizontal start
                    if (gridColumns == 2) and (isThreeUp == False):
                        # Align top left picture to the left
                        bottomLeftPicX = marginBase
                    else:
                        # Center sole top picture
                        bottomLeftPicX = midSlideX - bottomLeftPicWidth / 2

                # Calculate vertical start
                bottomLeftPicY = (
                    slideTitleBottom
                    + marginBase
                    + (maxPicHeight + bottomLeftPicHeight) / 2
                )

                if gridRows == 2:
                    bottomLeftPicY -= Inches(0.2)

                bottomLeftPicture = slide.shapes.add_picture(
                    bottomLeftGraphicFilename,
                    bottomLeftPicX,
                    bottomLeftPicY,
                    bottomLeftPicWidth,
                    bottomLeftPicHeight,
                )

                if bottomLeftGraphicHref == "":
                    bottomLeftGraphicHref = "#XYZZY-None"

                pictureInfos.append(
                    (bottomLeftPicture, bottomLeftGraphicHref, bottomLeftGraphicTitle)
                )

            if gridColumns == 2:
                # Bottom Right Picture
                if bottomRightGraphicFilename != "":
                    bottomRightHeightIfWidthUsed = (
                        maxPicWidth * bottomRightImgHeight / bottomRightImgWidth
                    )
                    bottomRightWidthIfHeightUsed = (
                        maxPicHeight * bottomRightImgWidth / bottomRightImgHeight
                    )

                    if bottomRightHeightIfWidthUsed > maxPicHeight:
                        # Use the height to scale
                        bottomRightPicWidth = bottomRightWidthIfHeightUsed
                        bottomRightPicHeight = maxPicHeight

                        # Calculate horizontal start
                        bottomRightPicX = (
                            presentation.slide_width
                            + midSlideX
                            - bottomRightPicWidth
                            - marginBase
                        ) / 2

                    else:
                        # Use the width to scale
                        bottomRightPicWidth = maxPicWidth
                        bottomRightPicHeight = bottomRightHeightIfWidthUsed

                        # Calculate horizontal start
                        bottomRightPicX = (
                            presentation.slide_width
                            + midSlideX
                            - bottomRightPicWidth
                            - marginBase
                        ) / 2

                    # Calculate vertical start
                    bottomRightPicY = (
                        slideTitleBottom
                        + marginBase
                        + (maxPicHeight + bottomRightPicHeight) / 2
                    )

                    if gridRows == 2:
                        bottomRightPicY -= Inches(0.2)

                    if isThreeUp == False:
                        bottomRightPicture = slide.shapes.add_picture(
                            bottomRightGraphicFilename,
                            bottomRightPicX,
                            bottomRightPicY,
                            bottomRightPicWidth,
                            bottomRightPicHeight,
                        )

                        if bottomRightGraphicHref == "":
                            bottomRightGraphicHref = "#XYZZY-None"

                        pictureInfos.append(
                            (
                                bottomRightPicture,
                                bottomRightGraphicHref,
                                bottomRightGraphicTitle,
                            )
                        )

    else:
        # Normal table slide

        # Calculate maximum number of columns - as this is how wide we'll make the table
        columns = 0
        for row in table:
            columns = max(columns, len(row))

        alignments = []
        widths = []

        # Adjust table if it contains a dash line as it's second line
        if len(table) > 1:
            firstCellSecondRow = table[1][0]
            if (firstCellSecondRow.startswith("-")) | (
                firstCellSecondRow.startswith(":-")
            ):
                haveTableHeading = True
            else:
                haveTableHeading = False
        else:
            haveTableHeading = False

        if haveTableHeading is True:
            # Has table heading
            tableHeadingBlurb = " with heading"
            # Figure out alignments of cells
            for cell in table[1]:
                if cell.startswith(":-"):
                    if cell.endswith("-:"):
                        alignments.append("c")
                    else:
                        alignments.append("l")
                elif cell.endswith("-:"):
                    alignments.append("r")
                else:
                    alignments.append("l")

                widths.append(cell.count("-"))
            widths_total = sum(widths)
            del table[1]
            wantTableHeading = True
        else:
            # No table heading
            tableHeadingBlurb = " without heading"
            wantTableHeading = False

            # Use default width - 1 - and default alignment - l
            for c in range(columns):
                widths.append(1)
                alignments.append("l")

            # We don't know the widths so treat all equal
            widths_total = columns

        # Calculate number of rows
        rows = len(table)
        alignments_count = len(alignments)

        # Figure out table height
        maxTableHeight = (
            presentation.slide_height
            - slideTitleBottom
            - numbersContentMargin
            - marginBase
        )
        tableHeight = min(maxTableHeight, Inches(0.25) * rows)

        # Figure out table top
        # tableTop = slideTitleBottom + marginBase + (maxTableHeight - tableHeight ) / 2
        tableTop = slideTitleBottom + Inches(0.5)

        # Figure out table width
        tableWidth = presentation.slide_width - 2 * tableMargin

        # Create the table with the above number of rows and columns
        newTable = shapes.add_table(
            rows, columns, tableMargin, tableTop, tableWidth, tableHeight
        ).table

        # Set whether first row is not special
        newTable.first_row = wantTableHeading

        print(
            str(slideNumber).rjust(4)
            + "     "
            + flattenedTitle.ljust(40)
            + "             --> "
            + str(rows)
            + " x "
            + str(columns)
            + " table"
            + tableHeadingBlurb
        )

        # Set column widths
        cols = newTable.columns
        for colno in range(columns):
            cols[colno].width = int(tableWidth * widths[colno] / widths_total)

        # Fill in the cells
        rowNumber = 0

        for row in table:
            columnNumber = 0

            # Add dummy cells to the end of the row so that there are as many
            # cells in the row as there are columns in the table
            cellCount = len(row)
            for c in range(cellCount, columns):
                row.append("")

            for cell in row:
                newCell = newTable.cell(rowNumber, columnNumber)

                # For compact table remove the margins around the text
                if compactTables > 0:
                    newCell.margin_top = Pt(0)
                    newCell.margin_bottom = Pt(0)

                newCell.text = ""
                text_frame = newCell.text_frame

                # Set cell's text alignment
                p = text_frame.paragraphs[0]

                # Set cell's text size - if necessary
                if baseTextSize > 0:
                    p.font.size = Pt(baseTextSize)

                # For compact table use specified point size for text
                if compactTables > 0:
                    p.font.size = Pt(compactTables)

                if columnNumber >= alignments_count:
                    p.alignment = PP_ALIGN.LEFT
                elif alignments[columnNumber] == "r":
                    p.alignment = PP_ALIGN.RIGHT
                elif alignments[columnNumber] == "c":
                    p.alignment = PP_ALIGN.CENTER
                else:
                    p.alignment = PP_ALIGN.LEFT

                addFormattedText(p, cell)

                columnNumber += 1

            rowNumber += 1

    if want_numbers_content is True:
        addFooter(presentation, slideNumber, slide)

    return slide


def createSlide(presentation, slideNumber, SI):
    if SI.blockType == "title":
        slide = createTitleOrSectionSlide(
            presentation,
            slideNumber,
            SI.titleText,
            titleSlideLayout,
            sectionTitleSize,
            SI.bodyText,
            sectionSubtitleSize,
        )

    elif SI.blockType == "section":
        if tocStyle != "":
            # This is a section slide in TOC style
            slide = createTOCSlide(
                presentation,
                slideNumber,
                SI.titleText,
                SI.bodyText,
                SI.bulletsOrFilename,
            )
        else:
            slide = createTitleOrSectionSlide(
                presentation,
                slideNumber,
                SI.titleText,
                sectionSlideLayout,
                sectionTitleSize,
                SI.bodyText,
                sectionSubtitleSize,
            )

    elif SI.blockType == "content":
        if (tocStyle != "") & (tocTitle == SI.titleText):
            # This is a Table Of Contents slide
            slide = createTOCSlide(
                presentation,
                slideNumber,
                SI.titleText,
                SI.bodyText,
                SI.bulletsOrFilename,
            )
        elif (abstractTitle != "") & (abstractTitle == SI.titleText):
            # This is an abstract slide
            slide = createAbstractSlide(
                presentation,
                slideNumber,
                SI.titleText,
                SI.bodyText,
                SI.bulletsOrFilename,
            )
        else:
            slide = createContentSlide(
                presentation,
                slideNumber,
                SI.titleText,
                SI.bodyText,
                SI.bulletsOrFilename,
            )
    elif SI.blockType == "code":
        # Note: Somehow two newlines got prepended to the code
        slide = createCodeSlide(
            presentation, slideNumber, SI.titleText, SI.bodyText[2:]
        )

    elif SI.blockType == "table":
        slide = createTableSlide(presentation, slideNumber, SI.titleText, SI.tableRows)

    slideNumber = slideNumber + 1

    return [slideNumber, slide]


def createTaskSlides(prs, slideNumber, tasks, titleStem):
    taskNumber = 0
    taskSlideNumber = 0

    taskCount = len(tasks)

    for task in tasks:
        if taskNumber % tasksPerPage == 0:
            # Is first task in a page
            if taskNumber > 0:
                # Print a "tasks" slide - as we have one to print out
                taskSlideNumber += 1
                if taskCount > tasksPerPage:
                    # More than one task page
                    title = titleStem + " - " + str(taskSlideNumber)
                else:
                    # Only one task page
                    title = titleStem

                slide = createTableSlide(prs, slideNumber, title, tableRows)
                slideNumber += 1

            tableRows = [["Slide", "Due", "Task", "Tags", "Done"]]
            tableRows.append(["-:", ":--:", ":----", ":----", ":--:"])
            old_sNum = 0

        sNum, taskText, dueDate, tags, done = task

        if tags != "":
            # Sort tags - if there are any
            tagList = re.split("[, ]", tags)
            sortedTagList = sorted(tagList)
            tags = str.join(",", sortedTagList)

        if sNum != old_sNum:
            tableRows.append([str(sNum), dueDate, taskText, tags, done])
        else:
            tableRows.append(["", dueDate, taskText, tags, done])
        old_sNum = sNum

        taskNumber += 1

    # Print a final "tasks" slide
    taskSlideNumber += 1
    if taskCount > tasksPerPage:
        title = titleStem + " - " + str(taskSlideNumber)
    else:
        title = titleStem

    slide = createTableSlide(prs, slideNumber, title, tableRows)

    # Fix up references to be active links to the slide where the task
    # was declared
    table = findBodyShape(slide).table
    for row in table.rows:
        cell0Text = row.cells[0].text
        if cell0Text not in ["Slide", ""]:
            run = row.cells[0].text_frame.paragraphs[0].runs[0]
            createRunHyperlinkOrTooltip(
                run, prs.slides[int(cell0Text) - 2 + templateSlideCount], ""
            )

    slideNumber += 1


def createGlossarySlides(prs, slideNumber, abbrevDictionary):
    termNumber = 0
    termSlideNumber = 0
    glossarySlides = []

    termCount = len(abbrevDictionary)

    for term in sorted(abbrevDictionary.keys()):
        if termNumber % glossaryTermsPerPage == 0:
            # Is first glossary term in a page
            if termNumber > 0:
                # Print a "glossary" slide - as we have one to print out
                termSlideNumber += 1
                if termCount > glossaryTermsPerPage:
                    # More than one glossary page
                    title = glossaryTitle + " - " + str(termSlideNumber)
                else:
                    # Only one glossary page
                    title = glossaryTerm

                slide = createTableSlide(prs, slideNumber, title, tableRows)
                glossarySlides.append(slide)
                slideNumber += 1

            tableRows = [[glossaryTerm, glossaryMeaning]]
            tableRows.append([":-", ":" + ("-" * glossaryMeaningWidth)])
            old_sNum = 0

        meaning = abbrevDictionary.get(term)

        tableRows.append([term, meaning])

        termNumber += 1

    # Print a final "glossary" slide
    termSlideNumber += 1
    if termCount > glossaryTermsPerPage:
        # More than one glossary page
        title = glossaryTitle + " - " + str(termSlideNumber)
    else:
        # Only one glossary page
        title = glossaryTitle

    slide = createTableSlide(prs, slideNumber, title, tableRows)
    glossarySlides.append(slide)
    slideNumber += 1

    return slideNumber, glossarySlides


def createFootnoteSlides(prs, slideNumber, footnoteDefinitions):
    footnoteNumber = 0
    footnotesSlideNumber = 0
    footnoteSlides = []

    footnoteCount = len(footnoteDefinitions)

    for footnote in footnoteDefinitions:
        if footnoteNumber % footnotesPerPage == 0:
            # Is first footnote in a page
            if footnoteNumber > 0:
                # Print a "footnotes" slide - as we have one to print out
                footnotesSlideNumber += 1
                if footnoteCount > footnotesPerPage:
                    # More than one footnotes page
                    title = footnotesTitle + " - " + str(footnotesSlideNumber)
                else:
                    # Only one footnotes page
                    title = footnotesTitle

                slide = createContentSlide(prs, slideNumber, title, "", bullets)
                footnoteSlides.append(slide)

                # Turn off bulleting
                removeBullets(findBodyShape(slide).text_frame)

                slideNumber += 1
            bullets = []
            old_sNum = 0

        bullets.append(
            [1, str(footnoteNumber + 1) + ". " + footnoteDefinitions[footnoteNumber][1]]
        )

        footnoteNumber += 1

    # Print a final "footnote" slide
    footnotesSlideNumber += 1
    if footnoteCount > footnotesPerPage:
        # More than one footnotes page
        title = footnotesTitle + " - " + str(footnotesSlideNumber)
    else:
        # Only one glossary page
        title = footnotesTitle

    slide = createContentSlide(prs, slideNumber, title, "", bullets)
    footnoteSlides.append(slide)

    # Turn off bulleting
    removeBullets(findBodyShape(slide).text_frame)

    slideNumber += 1

    return slideNumber, footnoteSlides


start_time = time.time()

banner = (
    "md2pptx Markdown To Powerpoint Converter " + md2pptx_level + " " + md2pptx_date
)

bannerUnderline = ""
for i in range(len(banner)):
    bannerUnderline = bannerUnderline + "="

print("\n" + banner + "\n" + bannerUnderline)
print("Open source project: https://github.com/MartinPacker/md2pptx")

input_file = []

if len(sys.argv) > 2:
    # Have input file as well as output file
    input_filename = sys.argv[1]
    output_filename = sys.argv[2]

    if Path(input_filename).exists():
        input_path = Path(input_filename)
        with input_path.open() as file:
            input_file = file.readlines()
    else:
        print("Input file specified but does not exist. Terminating.")
elif len(sys.argv) == 1:
    print("No parameters. Terminating")
    sys.exit()
else:
    output_filename = sys.argv[1]

    input_file = sys.stdin.readlines()

if len(input_file) == 0:
    print("Empty input file. Terminating")
    sys.exit()

slideNumber = 1

bulletRegex = re.compile("^(\s)*(\*)(.*)")
numberRegex = re.compile("^(\s)*(\d+)\.(.*)")
metadataRegex = re.compile("^(.+):(.+)")

graphicRE = "!\[(.*?)\]\((.+?)\)"
clickableGraphicRE = "\[" + graphicRE + "\]\((.+?)\)"
graphicRegex = re.compile(graphicRE)
clickableGraphicRegex = re.compile(clickableGraphicRE)

neitherClickableGraphicRegex = re.compile(graphicRE + "(.*?)" + graphicRE)
leftClickableGraphicRegex = re.compile(clickableGraphicRE + "(.*?)" + graphicRE)
rightClickableGraphicRegex = re.compile(graphicRE + "(.*?)" + clickableGraphicRE)
bothClickableGraphicRegex = re.compile(
    clickableGraphicRE + "(.*?)" + clickableGraphicRE
)

linkRegex = re.compile("^\[(.+)\]\((.+)\)")
twoUpRegex = re.compile("^\|(.+?)\|(.+?)\|")
footnoteDefinitionRegex = re.compile("^\[\^(.+?)]: (.+)")
spanRegex = re.compile("<span( )*class=")
slideHrefRegex = re.compile("\[(.+)\]\(.+\)")
anchorRegex = re.compile("^<a id=[\"'](.+)[\"']></a>")
dynamicMetadataRegex = re.compile("^<!-- md2pptx: (.+): (.+) -->")


# Default slide layout enumeration
titleSlideLayout = 0
sectionSlideLayout = 1
contentSlideLayout = 2
titleOnlyLayout = 5
blankLayout = 6

# Abbreviation Dictionary
abbrevDictionary = {}

# Abbreviation Runs Dictionary
abbrevRunsDictionary = {}

# Footnote runs Dictionary
footnoteRunsDictionary = {}

# Extract metadata
metadata_lines = []
afterMetadataAndHTML = []

inMetadata = True
in_comment = False
inHTML = False
inCode = False

for line in input_file:
    if line.lstrip().startswith("<!-- md2pptx: "):
        # md2pptx dynamic metadata so keep it
        afterMetadataAndHTML.append(line)

    if line.lstrip().startswith("<!--"):
        if line.rstrip().endswith("-->"):
            # Note: Not taking text after end of comment
            continue
        else:
            in_comment = True
            continue

    elif line.rstrip().endswith("-->"):
        # Note: Not taking text after end of comment
        in_comment = False
        continue

    elif in_comment is True:
        continue

    elif (line.lstrip()[:1] == "<") & (inCode is False):
        lineLstrip = line.lstrip()
        if startswithOneOf(lineLstrip, ["<a id=", "<span "]):
            # Line goes to post-metadata array
            afterMetadataAndHTML.append(line)

        elif startswithOneOf(lineLstrip, ["<code>", "<pre>"]):
            inCode = True
            afterMetadataAndHTML.append(line)

        elif startswithOneOf(lineLstrip, ["</code>", "</pre>"]):
            inCode = False
            afterMetadataAndHTML.append(line)
        else:
            inHTML = True
        continue

    elif line.startswith("```"):
        inCode = ~inCode
        # afterMetadataAndHTML.append(line)

    elif line.lstrip()[:1] == "#":
        # Heading has triggered end of metadata and end of HTML
        inMetadata = False
        inHTML = False

    elif inHTML:
        continue

    elif inCode:
        afterMetadataAndHTML.append(line)
        continue

    elif line == "\n":
        # Blank line has triggered end of metadata
        inMetadata = False

    if inMetadata is True:
        # Line goes to metadata array
        metadata_lines.append(line)

    else:
        # Line goes to post-metadata array
        afterMetadataAndHTML.append(line)

want_numbers_headings = False
want_numbers_content = False
slideTemplateFile = ""

defaultPageTitleSize = 30
pageTitleSize = defaultPageTitleSize
presPageTitleSize = defaultPageTitleSize

defaultBaseTextSize = 18
presBaseTextSize = defaultBaseTextSize
baseTextSize = defaultBaseTextSize

defaultBaseTextDecrement = 2
presBaseTextDecrement = defaultBaseTextDecrement
baseTextDecrement = defaultBaseTextDecrement

sectionTitleSize = 40
sectionSubtitleSize = 28
monoFont = "Courier"
tocStyle = ""
tocTitle = "Topics"
tocEntries = []

want_bold_colour = False
want_bold_bold = True
want_italic_colour = False
want_italic_italic = True

want_card_colour = False
want_card_border_colour = False
want_card_border_width = False
want_card_title_size = False
want_card_shadow = False

defaultCardPercent = 80
cardPercent = defaultCardPercent
presCardPercent = defaultCardPercent

defaultCompactTables = 0
compactTables = defaultCompactTables
presCompactTables = defaultCompactTables

defaultCardLayout = "horizontal"
cardLayout = defaultCardLayout
presCardLayout = defaultCardLayout

defaultCardTitleAlign = "c"
cardTitleAlign = defaultCardTitleAlign
presCardTitleAlign = defaultCardTitleAlign

defaultCardTitlePosition = "above"
cardTitlePosition = defaultCardTitlePosition
presCardTitlePosition = defaultCardTitlePosition

defaultCardShape = "rounded"
cardShape = defaultCardShape
presCardShape = defaultCardShape

abstractTitle = ""

taskSlides = "all"
tasksPerPage = 20

glossaryTitle = "Glossary"
glossaryTerm = "Term"
glossaryMeaning = "Meaning"
glossaryMeaningWidth = 5
glossaryTermsPerPage = 20
footnotesTitle = "Footnotes"
footnotesPerPage = 20

metadata = []
marginBase = Inches(0.2)
tableMargin = Inches(0.2)

# Space to leave at bottom if numbers
numbersHeight = Inches(0.4)

# If no numbers leave all the above height anyway
numbersContentMargin = numbersHeight
numbersHeadingsMargin = numbersContentMargin

# Background colour class correspondence
bgcolors = {}

# Foreground colour class correspondence
fgcolors = {}

# Emphases class correspondence
emphases = {}

# List of footnote definitions. Each is a (ref, text) pair.
# Also array of names - for quick searching
footnoteDefinitions = []
footnoteReferences = []

if len(metadata_lines) > 0:
    print("")
    print("Metadata:")
    print("=========")
    print("")
    print("Name".ljust(40) + " " + "Value")
    print("----".ljust(40) + " " + "-----")
for line in metadata_lines:
    matchInfo = metadataRegex.match(line)
    name = matchInfo.group(1).strip()
    value = matchInfo.group(2).strip()
    metadata.append([name, value])

    # Print name as it was typed
    print(name.ljust(40) + " " + value)

    # Lower case name for checking
    name = name.lower()

    if name == "numbers":
        if value.lower() == "yes":
            # Want slide numbers everywhere
            want_numbers_headings = True
            numbersHeadingsMargin = numbersHeight
            want_numbers_content = True
            numbersContentMargin = numbersHeight
        elif value.lower() == "content":
            # Want slide numbers on content slides but not headings & sections
            want_numbers_headings = False
            want_numbers_content = True
            numbersContentMargin = numbersHeight
        else:
            # Don't want slide numbers - but they could still be added by slide master
            # (Can code any other value, including 'no' or omit this metadata type)
            want_numbers_headings = False
            want_numbers_content = False

    elif name == "pagetitlesize":
        pageTitleSize = float(value)
        presPageTitleSize = pageTitleSize

    elif name == "basetextsize":
        baseTextSize = float(value)
        presBaseTextSize = baseTextSize

    elif name == "basetextdecrement":
        baseTextDecrement = float(value)
        presBaseTextDecrement = baseTextDecrement

    elif name == "sectiontitlesize":
        sectionTitleSize = float(value)

    elif name == "sectionsubtitlesize":
        sectionSubtitleSize = float(value)

    elif (name == "template") | (name == "master"):
        if value == "Martin Master.pptx":
            slideTemplateFile = "Martin Template.pptx"
        else:
            slideTemplateFile = value

    elif name == "monofont":
        monoFont = value

    elif name == "marginbase":
        marginBase = Inches(float(value))

    elif name == "tablemargin":
        tableMargin = Inches(float(value))

    elif name == "tocstyle":
        tocStyle = value

    elif name == "toctitle":
        tocTitle = value

    elif name == "abstracttitle":
        abstractTitle = value

    elif name == "boldbold":
        if value.lower() == "no":
            want_bold_bold = False

    elif name == "compacttables":
        compactTables = float(value)
        presCompactTables = compactTables

    elif (name == "boldcolour") | (name == "boldcolour"):
        want_bold_colour = True
        bold_colour = parseThemeColour(value)

    elif name == "italicitalic":
        if value == "no":
            want_italic_italic = False

    elif (name == "italiccolour") | (name == "italiccolor"):
        want_italic_colour = True
        italic_colour = parseThemeColour(value)

    elif (name == "cardcolour") | (name == "cardcolor"):
        want_card_colour = True
        card_colour = parseThemeColour(value)

    elif (name == "cardbordercolour") | (name == "cardbordercolor"):
        want_card_border_colour = True
        card_border_colour = parseThemeColour(value)

    elif name == "cardborderwidth":
        want_card_border_width = True
        card_border_width = float(value)

    elif name == "cardtitlesize":
        want_card_title_size = True
        cardTitleFontSize = float(value)

    elif name == "cardshadow":
        if value.lower() == "yes":
            want_card_shadow = True

    elif name == "cardpercent":
        cardPercent = float(value)
        presCardPercent = cardPercent

    elif name == "cardlayout":
        if value in ["horizontal", "vertical"]:
            cardLayout = value
            presCardLayout = value
        else:
            print(
                f'CardLayout value \'{value}\' unsupported. "horizontal" or "vertical" required.'
            )

    elif name == "cardshape":
        if value in ["squared", "rounded"]:
            cardShape = value
            presCardShape = value
        else:
            print(
                f'CardShape value \'{value}\' unsupported. "squared" or "rounded" required.'
            )

    elif name == "cardtitleposition":
        if value in ["above", "inside"]:
            cardTitlePosition = value
            presCardTitlePosition = value
        else:
            print(
                f'CardTitlePosition value \'{value}\' unsupported. "inside" or "above" required.'
            )

    elif name == "cardtitlealign":
        val1l = value[:1].lower()
        if val1l in ["l", "r", "c"]:
            cardTitleAlign = val1l
            presCardTitleAlign = cardTitleAlign
        else:
            print(f"CardAlign value '{value}' unsupported.")

    elif name == "taskslides":
        taskSlides = value

    elif name == "tasksperpage":
        tasksPerPage = int(value)

    elif name == "titleslidelayout":
        titleSlideLayout = int(value)

    elif name == "sectionslidelayout":
        sectionSlideLayout = int(value)

    elif name == "contentslidelayout":
        contentSlideLayout = int(value)

    elif name == "titleonlylayout":
        titleOnlyLayout = int(value)

    elif name == "blanklayout":
        blankLayout = int(value)

    elif name == "numbersheight":
        numbersHeight = Inches(float(value))

        # If no numbers leave all the above height anyway
        numbersContentMargin = numbersHeight
        numbersHeadingsMargin = numbersContentMargin

    elif name == "glossarytitle":
        glossaryTitle = value
    elif name == "glossaryterm":
        glossaryTerm = value
    elif name == "glossarymeaning":
        glossaryMeaning = value
    elif name == "glossarymeaningwidth":
        glossaryMeaningWidth = int(value)
    elif name == "glossarytermsperpage":
        glossaryTermsPerPage = int(value)
    elif name == "footnotesperpage":
        footnotesPerPage = int(value)
    elif name == "footnotestitle":
        footnotesTitle = value
    elif name.startswith("style.bgcolor."):
        spanClass = name[14:]
        bgcolors[spanClass] = value
    elif name.startswith("style.fgcolor."):
        spanClass = name[14:]
        fgcolors[spanClass] = value
    elif name.startswith("style.emphasis."):
        spanClass = name[15:]
        emphases[spanClass] = value

if slideTemplateFile != "":
    originalSlideTemplateFile = slideTemplateFile
    if Path(os.path.expanduser(slideTemplateFile)).exists():
        # We can successfully expand the path to pick up the file
        slideTemplateFile = os.path.expanduser(slideTemplateFile)
    else:
        # Slide template file is not present if we expand path
        script_path = os.path.dirname(__file__)
        slideTemplateFile = script_path + os.sep + slideTemplateFile
        if not Path(slideTemplateFile).exists():
            print(
                f"\nTemplate file {originalSlideTemplateFile} does not exist. Terminating."
            )
            sys.exit()

    print(f"\nUsing {slideTemplateFile} as base for presentation")

if slideTemplateFile == "":
    # Use default slide deck that comes with python-pptx as base
    prs = Presentation()
    print("\nNo slide to document metadata on. Continuing without it.")

    templateSlideCount = 0
else:
    # Use user-specified presentation as base
    prs = Presentation(slideTemplateFile)

    # If there is a slide to use fill it with metadata
    templateSlideCount = len(prs.slides)
    if templateSlideCount > 0:
        createProcessingSummarySlide(prs, metadata)
        print("\nWriting processing summary slide with metadata on it.")
    else:
        print("\nNo slide to document metadata on. Continuing without it.")

print("")
print("Slides:")
print("=======")
print("")

inBlock = False
inList = False
inTable = False
inCard = False

blockType = ""
slideTitle = ""
slideSubtitle = ""
bullets = []
tableRows = []
inCode = False
inHTMLCode = False
inFencedCode = False
notes_text = ""
slide = None
tasks = []

slideHrefs = {}
href_runs = {}

# Each of these is a picture, then a href, then a tooltip - as a tuple
pictureInfos = []

# Pass to concatenate lines with continuations
previousLine = "\n"
linesAfterConcatenation = []

for line in afterMetadataAndHTML:
    if startswithOneOf(line, ["<pre>", "<code>"]):
        # These are around code lines
        linesAfterConcatenation.append(line)
        inHTMLCode = True

    elif startswithOneOf(line, ["</pre>", "</code>"]):
        # These are around code lines
        linesAfterConcatenation.append(line)
        inHTMLCode = False

    elif line.startswith("```"):
        linesAfterConcatenation.append(line)
        inCode = not inCode

    elif line == "\n":
        # This is a blank line so copy it over
        linesAfterConcatenation.append(line)

    elif previousLine == "\n":
        # Previous line was blank so copy this one over
        linesAfterConcatenation.append(line)

    elif line.startswith("<!-- md2pptx: "):
        # This is a dynamic metadata line so keep it separate
        linesAfterConcatenation.append(line)

    elif line.startswith("<a id="):
        # This is an anchor line so keep it separate
        linesAfterConcatenation.append(line)

    elif line.lstrip() == "":
        # This is an empty line
        linesAfterConcatenation.append(line)

    else:
        # Previous line was not blank and nor is this one so consider concatenation
        if line.lstrip()[0] not in "*#\|0123456789!":
            if (
                (previousLine[0:2] != "# ")
                & (previousLine[0:3] != "## ")
                & (previousLine[0:4] != "    ")
                & (inCode is False)
                & (inHTMLCode is False)
            ):
                # Previous line was not Heading Level 1 or 2 and we're not in code so concatenate
                linesAfterConcatenation[-1] = (
                    linesAfterConcatenation[-1].rstrip() + " " + line.lstrip()
                )
            else:
                linesAfterConcatenation.append(line)

        else:
            linesAfterConcatenation.append(line)

    # Store previous line to see if it was H1 or blank
    previousLine = line

# Pass to get footnote definitions
metadataLinenumber = 0
for line in linesAfterConcatenation:
    line = line.rstrip()
    if (m := footnoteDefinitionRegex.match(line)) :
        fnRef = m.group(1).strip()
        fnText = m.group(2).strip()
        footnoteDefinitions.append([fnRef, fnText])
        footnoteReferences.append(fnRef)

        linesAfterConcatenation[metadataLinenumber] = "<ignoreme>"
    metadataLinenumber += 1

# Main pass over the input file, now that footnote
# references have been gathered
for line in linesAfterConcatenation:
    line = line.rstrip()
    line = line.replace("\t", "    ")

    if line == "<ignoreme>":
        # Line was taken care of in the previous pass
        continue

    if startswithOneOf(line, ["<pre>", "<code>"]):
        code = []
        inCode = True
        inHTMLCode = True

    if startswithOneOf(line, ["</pre>", "</code>"]):
        inCode = True
        inHTMLCode = False

    if line.startswith("```"):
        inCode = not inCode
        if inCode:
            # Just entered code
            code = []
            blockType = "code"
        inFencedCode = not inFencedCode

    if inCode or inHTMLCode or inFencedCode:
        code.append(line)

    if (
        (line == "")
        & (inCode is True)
        & (inHTMLCode is False)
        & (inFencedCode is False)
    ):
        inCode = False

    if (line.startswith("    ")) & (inList is False):
        if inCode is False:
            code = []
        blockType = "code"
        code.append(line[4:])
        inCode = True

    # Rewrite horizontal rule as a heading 3 with non-breaking space
    if startswithOneOf(line, ["<hr/>", "---", "***", "___"]):
        line = "### &nbsp;"

    # Taskpaper task
    if line[:1] == "-":
        # Get start of attributes
        attributesStart = line.find("@")

        # Get text up to attributes
        if attributesStart == -1:
            text = line[2:]
        else:
            text = line[2 : attributesStart - 1]

        # Attempt to extract @due information
        startDue = line.find("@due(")
        if startDue > -1:
            startDue += 5
            endDue = line.find(")", startDue)
            if endDue > -1:
                dueDate = line[startDue:endDue]
        else:
            dueDate = ""

        # Attempt to extract @tags information
        startTags = line.find("@tags(")
        if startTags > -1:
            startTags += 6
            endTags = line.find(")", startTags)
            if endTags > -1:
                tags = line[startTags:endTags]
        else:
            tags = ""

        # Attempt to extract @done information
        startDone = line.find("@done(")
        if startDone > -1:
            startDone += 6
            endDone = line.find(")", startDone)
            if endDone > -1:
                done = line[startDone:endDone]
        else:
            done = ""

        tasks.append([slideNumber + 1, text, dueDate, tags, done])

    elif line.startswith("<a id="):
        # Anchor on whatever slide we're on
        if (hrefMatch := anchorRegex.match(line)) :
            href = hrefMatch.group(1)
            if (href != "") & (href in slideHrefs.keys()):
                print(f"Heading Reference redefined: '{href}' for slide {slideNumber}")

    elif line.startswith("<!-- md2pptx: "):
        # Dynamic metadata line
        if (DMMatch := dynamicMetadataRegex.match(line)) :
            metadataKey = DMMatch.group(1).lower()
            metadataValue = DMMatch.group(2).lower()
            if (metadataKey != "") & (metadataValue != ""):
                # Valid metadata pair so parse key / value - and apply if valid
                if metadataKey == "compacttables":
                    # Font size for tables
                    if metadataValue == "default":
                        compactTables = defaultCompactTables

                    elif metadataValue == "pres":
                        compactTables = presCompactTables

                    else:
                        compactTables = float(metadataValue)

                elif metadataKey == "pagetitlesize":
                    # Page Title Font size
                    if metadataValue == "default":
                        pageTitleSize = defaultPageTitleSize

                    elif metadataValue == "pres":
                        pageTitleSize = presPageTitleSize

                    else:
                        pageTitleSize = float(metadataValue)

                elif metadataKey == "cardpercent":
                    # Cards' vertical percent of content area
                    if metadataValue == "default":
                        cardPercent = defaultCardPercent

                    elif metadataValue == "pres":
                        cardPercent = presCardPercent

                    else:
                        cardPercent = float(metadataValue)

                elif metadataKey == "cardlayout":
                    # Cards' layout - horizontal or vertical
                    if metadataValue == "default":
                        cardLayout = defaultCardLayout

                    elif metadataValue == "pres":
                        cardLayout = presCardLayout

                    else:
                        cardLayout = metadataValue

                elif metadataKey == "basetextsize":
                    # Base text size
                    if metadataValue == "default":
                        baseTextSize = defaultBaseTextSize

                    elif metadataValue == "pres":
                        baseTextSize = presBaseTextSize

                    else:
                        baseTextSize = float(metadataValue)

                elif metadataKey == "basetextdecrement":
                    # Base text decrement
                    if metadataValue == "default":
                        baseTextDecrement = defaultBaseTextDecrement

                    elif metadataValue == "pres":
                        baseTextDecrement = presBaseTextDecrement

                    else:
                        baseTextDecrement = float(metadataValue)

                elif metadataKey == "cardtitlealign":
                    # Card title alignment
                    if metadataValue == "default":
                        cardTitleAlign = defaultCardTitleAlign

                    elif metadataValue == "pres":
                        cardTitleAlign = presCardTitleAlign

                    else:
                        cardTitleAlign = metadataValue[:1].lower()

                elif metadataKey == "cardtitleposition":
                    # Card title position - above or inside
                    if metadataValue == "default":
                        cardTitlePosition = defaultCardTitlePosition

                    elif metadataValue == "pres":
                        cardTitlePosition = presCardTitlePosition

                    else:
                        cardTitlePosition = metadataValue

                else:
                    # Invalid dynamic metadata specification
                    print(f"Invalid dynamic metadata key: '{metadataKey}' in '{line}'")

    elif line[:4] == "####":
        # Heading Level 4 - card on an existing slide
        inCard = True

        # If there is an outstanding href then store it
        if href != "":
            slideHrefs[href] = slideNumber + 1

        # Get card title text and any href
        cardName, href = parseTitleText(line[4:])
        if (href != "") & (href in slideHrefs.keys()):
            print(f"Heading Reference redefined: '{href}' for slide {slideNumber}")

        # Create information about a card_title
        cardBullets = []
        cards.append([cardName])

    elif line[:3] == "###":
        # Heading Level 3 - slide
        if inBlock is True:
            # Create the previous slide
            SI = slideInfo(slideTitle, slideSubtitle, blockType, bullets, tableRows)
            slideNumber, slide = createSlide(prs, slideNumber, SI)

            if href != "":
                slideHrefs[href] = slideNumber

        # Get slide title text and any href
        slideTitle, href = parseTitleText(line[3:])
        if (href != "") & (href in slideHrefs.keys()):
            print(f"Heading Reference redefined: '{href}' for slide {slideNumber}")

        inBlock = True
        blockType = "content"
        slideSubtitle = ""
        bullets = []
        inList = False
        inTable = False
        inCard = False
        cards = []

        if (notes_text != "") & (slide != None):
            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes_text

        notes_text = ""

    elif line[:2] == "##":
        # Heading Level 2 - section
        if inBlock is True:
            SI = slideInfo(slideTitle, slideSubtitle, blockType, bullets, tableRows)
            slideNumber, slide = createSlide(prs, slideNumber, SI)

            if href != "":
                slideHrefs[href] = slideNumber

        # Get slide title text and any href
        slideTitle, href = parseTitleText(line[2:])
        if (href != "") & (href in slideHrefs.keys()):
            print(f"Heading Reference redefined: '{href}' for slide {slideNumber}")

        inBlock = True
        blockType = "section"
        slideSubtitle = ""
        bullets = []
        inList = False
        inTable = False
        inCard = False

        if (notes_text != "") & (slide != None):
            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes_text

        notes_text = ""

    elif line[:1] == "#":
        # Heading Level 1 - slide title
        if inBlock is True:
            SI = slideInfo(slideTitle, slideSubtitle, blockType, bullets, tableRows)
            slideNumber, slide = createSlide(prs, slideNumber, SI)

            if href != "":
                slideHrefs[href] = slideNumber

        # Get slide title text and any href
        slideTitle, href = parseTitleText(line[1:])
        if (href != "") & (href in slideHrefs.keys()):
            print(f"Heading Reference redefined: '{href}' for slide {slideNumber}")

        inBlock = True
        blockType = "title"
        slideSubtitle = ""
        bullets = []
        inList = False
        inTable = False
        inCard = False

        if (notes_text != "") & (slide != None):
            notes_slide = slide.notes_slide
            text_frame = notes_slide.notes_text_frame
            text_frame.text = notes_text

        notes_text = ""

    elif (match := bulletRegex.match(line)) :
        # Bulleted inList
        bulletLine = match.group(3).lstrip()
        bulletLevel = int(match.start(2) / 2) + 1
        bulletType = "bulleted"
        if inCard:
            cardBullets.append([bulletLevel, bulletLine, bulletType])
            cardsLength = len(cards)
            if len(cards[cardsLength - 1]) == 1:
                cards[cardsLength - 1].append(cardBullets)
            else:
                cards[cardsLength - 1][1] = cardBullets
        else:
            bullets.append([bulletLevel, bulletLine, bulletType])
        inList = True
        inTable = False

    elif (match := numberRegex.match(line)) :
        bulletLine = match.group(3).lstrip()
        bulletLevel = int(match.start(2) / 2) + 1
        bulletType = "numbered"
        if inCard:
            cardBullets.append([bulletLevel, bulletLine, bulletType])
            cardsLength = len(cards)
            if len(cards[cardsLength - 1]) == 1:
                cards[cardsLength - 1].append(cardBullets)
            else:
                cards[cardsLength - 1][1] = cardBullets
        else:
            bullets.append([bulletLevel, bulletLine, bulletType])
        inList = True
        inTable = False

    elif (graphicRegex.match(line) != None) | (
        clickableGraphicRegex.match(line) != None
    ):
        # There is at least one graphic in the line - whether clickable or not
        if inTable is False:
            blockType = "table"
            tableRows = []
            inTable = True
            inList = False
            inCard = False

        # Create a table row
        tableRow = []

        if len(graphicRegex.findall(line)) == 2:
            # Two graphics - whether clickable or not - on same line
            if (matches := bothClickableGraphicRegex.match(line)) :
                leftGraphic = (
                    "[![" + matches[1] + "](" + matches[2] + ")](" + matches[3] + ")"
                )

                rightGraphic = (
                    "[![" + matches[5] + "](" + matches[6] + ")](" + matches[7] + ")"
                )

            elif (matches := leftClickableGraphicRegex.match(line)) :
                leftGraphic = (
                    "[![" + matches[1] + "](" + matches[2] + ")](" + matches[3] + ")"
                )

                rightGraphic = "![" + matches[5] + "](" + matches[6] + ")"

            elif (matches := rightClickableGraphicRegex.match(line)) :
                leftGraphic = "![" + matches[1] + "](" + matches[2] + ")"

                rightGraphic = (
                    "[![" + matches[4] + "](" + matches[5] + ")](" + matches[6] + ")"
                )

            else:
                matches = neitherClickableGraphicRegex.match(line)
                leftGraphic = "![" + matches[1] + "](" + matches[2] + ")"

                rightGraphic = "![" + matches[4] + "](" + matches[5] + ")"

            tableRow.append(leftGraphic)
            tableRow.append(rightGraphic)

        else:
            # One graphic - whether clickable or not - on the line

            tableRow.append(line)

        # Add table row to saved table rows
        tableRows.append(tableRow)

    elif line[:1] == "|":
        # Table or side-by-side
        if inTable is False:
            blockType = "table"
            tableRows = []
            inTable = True
            inList = False
            inCard = False

        # Create a table row - but with (maybe empty) junk before and after
        words = line.split("|")
        tableRow = []
        for cell in words:
            tableRow.append(cell)

        # Remove first element
        tableRow.pop(0)

        # Remove last element - if blank
        if cell == "":
            tableRow.pop()

        # Add clean table row (inList of cells) to saved table rows
        tableRows.append(tableRow)

    else:
        # Must be a slide note line
        slideSubtitle = slideSubtitle + "\n" + line
        notes_text = notes_text + "\n" + line

#  Finish off last slide
if (inBlock is True) | (inCode is True) | (inTable is True):
    SI = slideInfo(slideTitle, slideSubtitle, blockType, bullets, tableRows)
    slideNumber, slide = createSlide(prs, slideNumber, SI)

    if href != "":
        slideHrefs[href] = slideNumber

    if (notes_text != "") & (slide != None):
        notes_slide = slide.notes_slide
        text_frame = notes_slide.notes_text_frame
        text_frame.text = notes_text

    notes_text = ""

# Add a footnotes slide - if there were any footnote definitions
if len(footnoteDefinitions) > 0:
    slideNumber, footnoteSlides = createFootnoteSlides(
        prs, slideNumber, footnoteDefinitions
    )

    # Fix up any footnote slide hyperlinks
    footnoteNumber = -1
    for footnoteRun in footnoteRunsDictionary.keys():
        footnoteNumber += 1
        run = footnoteRunsDictionary[footnoteRun]

        footnoteSlideNumber = int(footnoteNumber / footnotesPerPage)
        createRunHyperlinkOrTooltip(run, footnoteSlides[footnoteSlideNumber], "")


# Add a dictionary slide - if there were any abbr elements encountered
if len(abbrevDictionary) > 0:
    slideNumber, glossarySlides = createGlossarySlides(
        prs, slideNumber, abbrevDictionary
    )
    # Fix up internal glossary hyperlinks
    abbrevNumber = -1
    for abbreviation in sorted(abbrevRunsDictionary.keys()):
        abbrevNumber += 1
        runs = abbrevRunsDictionary[abbreviation]
        for run in runs:
            # Add tooltip for glossary definition
            glossarySlideNumber = int(abbrevNumber / glossaryTermsPerPage)
            createRunHyperlinkOrTooltip(
                run, glossarySlides[glossarySlideNumber], abbrevDictionary[abbreviation]
            )


# Add final slide - or more than one - with any Taskpaper tasks in
if (len(tasks) > 0) & (taskSlides != "none"):
    # Turn tasks into a table slide

    # Might need to winnow slides
    if taskSlides != "all":
        complete = []
        incomplete = []
        for task in tasks:
            sNum, taskText, dueDate, tags, done = task
            if done == "":
                incomplete.append(task)
            else:
                complete.append(task)

        if (taskSlides == "separate") & (len(tasks) > 0):
            want_task_slides = True
        elif (taskSlides == "remaining") & (len(incomplete) > 0):
            want_task_slides = True
        elif (taskSlides == "done") & (len(complete) > 0):
            want_task_slides = True
        else:
            want_task_slides = False
    else:
        want_task_slides = True

    if want_task_slides:
        if taskSlides != "separate":
            createTaskSlides(prs, slideNumber, tasks, "Tasks")
        else:
            createTaskSlides(prs, slideNumber, complete, "Completed Tasks")
            createTaskSlides(prs, slideNumber, incomplete, "Incomplete Tasks")

# Fix up any internal links
xrefCheck_errors = False
for href in href_runs.keys():
    run = href_runs[href]
    if href in slideHrefs.keys():
        createRunHyperlinkOrTooltip(
            run, prs.slides[slideHrefs[href] - 2 + templateSlideCount], ""
        )
    else:
        # No id defined with that name
        if not xrefCheck_errors:
            # First time in this run a cross reference error occurred
            xrefCheck_errors = True
            print("\nHyperlink Reference Errors")
            print("--------------------------")

        print(
            "Slide "
            + str(prs.slides.index(SlideFromRun(run)) + 1 - templateSlideCount)
            + f": '{href}'"
        )

# Each picture appears in pictures
# There's a corresponding entry in picture_Hrefs
# There's a corresponding entry in picture_tooltips

# fix up any clickable picture links
picture_count = len(pictureInfos)
for p in range(picture_count):
    picture, href, tooltip = pictureInfos[p]

    # Pick up link target - if any
    if href == "#XYZZY-None":
        target = None
    else:
        if href[1:] in slideHrefs.keys():
            # Is an internal link
            target = prs.slides[slideHrefs[href[1:]] - 2 + templateSlideCount]
        else:
            # Is an external Link
            target = href

    createPictureHyperlinkOrTooltip(picture, target, tooltip)

# Write out the finished presentation
prs.save(output_filename)

elapsed_time = time.time() - start_time

print(
    "\nProcessing complete.\nElapsed time: "
    + str(int(1000 * elapsed_time) / 1000)
    + "s"
)

sys.exit()
